{"meta":{"title":"VIP","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-12-01T16:00:19.000Z","updated":"2018-12-01T16:00:19.830Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python实现23种设计模式","slug":"Python实现23种设计模式","date":"2018-12-02T20:29:01.422Z","updated":"2018-12-02T20:29:01.422Z","comments":true,"path":"2018/12/03/Python实现23种设计模式/","link":"","permalink":"http://yoursite.com/2018/12/03/Python实现23种设计模式/","excerpt":"","text":"","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"设计模式","slug":"设计模式","date":"2018-12-02T20:25:42.622Z","updated":"2018-12-02T20:25:42.624Z","comments":true,"path":"2018/12/03/设计模式/","link":"","permalink":"http://yoursite.com/2018/12/03/设计模式/","excerpt":"设计模式是面对各种问题进行提炼和抽象而形成的解决方案。这些设计方案是前人不断试验，考虑了封装性、复用性、效率、可修改、可移植等各种因素的高度总结。模式不是代码，而是某类问题的通用设计解决方案。","text":"设计模式是面对各种问题进行提炼和抽象而形成的解决方案。这些设计方案是前人不断试验，考虑了封装性、复用性、效率、可修改、可移植等各种因素的高度总结。模式不是代码，而是某类问题的通用设计解决方案。 一、设计模式与架构、框架的关系 1.软件框架与设计模式的关系 软件框架随着软件工程的发展而出现，所谓的软件框架，是提取了特定领域的软件的共性部分所形成的软件体系，它并不是一个成熟的软件，而更像是一个“半成品”，程序员在框架之上，可以很方便地某些特定领域实现又快又可靠的二次开发。设计模式和软件框架在软件设计中是两个不同的研究领域：A、设计模式如前边的定义所讲，它指的是针对一类问题的解决方法，一个设计模式可应用于不同的框架和被不同的语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体；B、设计模式相较于框架更容易移植，并且可以用各种语言实现，而软件框架则受限于领域大环境。虽然设计模式和软件框架有很多不同，但在某些方面他们二者是统一的，即重视软件复用，提高开发效率。 2.软件架构与设计模式的关系 软件架构是个比较大的概念，架构要考虑软件的整体结构、层次划分以及不同部分间的协作和交互等，架构的着眼点偏整体。相比之下，框架和设计模式的范围则具体很多，框架着眼于领域内的解决方法，而设计模式则针对一类问题的解决方案和设计思路。总体来说，软件架构可以由不同的框架和不同的设计模式，再加上特定的构件组合来实现；框架可以根据设计模式结合特定编程语言和环境来实现。设计模式就是解决单一问题的设计思路和解决方法。 二、设计模式的意义 由于公司人事的变动，代码非常有可能会被移交，即代码的编写者和维护者很有可能会是不同的人。那么代码的可读性就显得非常重要了。由于高级语言的出现，让机器读懂你的意图已经不是最主要的“矛盾”，而让人读懂你的意图才是最重要。按照设计模式编写的代码，其可读性也会大大提升，利于团队项目的继承和扩展 三、设计模式的种类 1.创建类设计模式（5种） 单例模式、工厂模式（简单工厂模式、抽象工厂模式）、建造者模式、原型模式 2.结构类设计模式（7种） 代理模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式、桥梁模式 3.行为类设计模式（11种） 策略模式、责任链模式、命令模式、中介者模式、模板模式、迭代器模式、访问者模式、观察者模式、解释器模式、备忘录模式、状态模式 四、设计模式遵循的六大原则 设计模式与设计原则，基本符合规则与原则的关系，设计模式是一个个具体问题的解决方案，设计原则则反映了这些设计模式的指导思想；同时，设计原则可衍生出的设计模式也不仅限于上述介绍到了23种设计模式，任何一种针对特定业务场景中的解决方法，虽然找不到对应的设计模式与之匹配，但若符合设计原则，也可以认为是一种全新的设计模式。从这个意义上来说，设计模式是程序设计方法的形，而设计原则是程序设计方法的神。 1.开闭原则（Open Close Principle） 开闭原则是非常基础的一个原则，也有人把开闭原则称为“原则的原则”。前面讲到过，模块分原子模块，低层模块，高层模块，业务层可以认为是最高层次的模块。对扩展开放，意味着模块的行为是可以扩展的，当高层模块需求改变时，我们可以对低层模块进行扩展，使其具有满足高层模块的新功能；对修改关闭，即对低层模块行为进行扩展时，不必改动模块的源代码。最理想的情况是，业务变动时，仅修改业务代码，不修改依赖的模块（类、函数等）代码，通过扩展依赖的模块单元来实现业务变化。 1假设一个原始基类水果类，苹果类是它的派生类，苹果中包含水果的各种属性，如形状、颜色等；另有两个类，农民类和花园类，最高层次（业务层次）为农民在花园种苹果。如果此时，农民决定不种苹果了，改种梨，符合OCP原则的设计应该为基于水果类构建一个新的类，即梨类（对扩展开放），而并不应该去修改苹果类，使它成为一个梨类（对修改关闭）。修改应仅在最高层，即业务层中进行。 2.里氏代换原则（Liskov Substitution Principle） 面向对象设计的最为基本原则之一。 里氏替换原则的含义为：任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当子类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，子类也能够在基类的基础上增加新的行为。 1对于一个鸟类，可以衍生出麻雀、喜鹊、布谷等子类，这些子类都可继承鸟类的鸣叫、飞行、吃食等接口。而对于一个鸡类，虽然它在生物学上属于鸟类，但它不会飞，那么符合LSP设计原则的情况下，鸡就不应该是鸟的一个子类：在鸟类调用飞行接口的地方，鸡类并不能出现。如果鸡类要使用鸟类的接口，应该使用关联关系，而不是继承关系。 3.依赖倒转原则（Dependence Inversion Principle） 高层模块不应该依赖于低层模块，两者都应该依赖其抽象。抽象不应该依赖于细节，细节应该依赖于抽象。我们将每个不可细分的逻辑叫作原子逻辑，原子逻辑组装，形成低层模块，低层模块组装形成高层模块。依赖倒置原则的含义为，高层模块和低层模块都应该由各自的抽象模块派生而来，同时接口设计应该依赖于抽象，而非具体模块。 1司机与汽车是依赖的关系，司机可以有实习司机类、老司机类等派生；汽车可以有轿车、SUV、卡车等派生类。如果司机中设计一个接口drive，汽车是其参数，符合DIP设计原则的参数，应该是在基类司机类中，将基类汽车类作为参数，而司机的派生类中，drive的参数同样应该为基类汽车类，而不应该是汽车类的任一个派生类。如果规定实习司机只能开轿车等业务逻辑，应该在其接口中进行判断，而不应该将参数替换成子类轿车。 4.接口隔离原则（Interface Segregation Principle） 类间的依赖关系不应该建立一个大的接口，而应该建立其最小的接口，即客户端不应该依赖那些它不需要的接口。这里的接口的概念是非常重要的。从逻辑上来讲，这里的接口可以指一些属性和方法的集合；从业务上来讲，接口就可以指特定业务下的接口（如函数，URL调用等）。接口应该尽量小，同时仅留给客户端必要的接口，弃用没有必要的接口。 1如果要根据具体的数据，生成饼图、直方图、表格，这个类该如何设计？如果将生成饼图、直方图、表格等“接口”（这里的接口就是“操作”的集合的概念），写在一个类中，是不符合接口隔离原则的。符合ISP原则的设计应该是设计三个类，每个类分别实现饼图、直方图、表格的绘制。 5.迪米特法则（最少知识原则）（Demeter Principle）（Least Knowledge Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 1一个公司有多个部门，每个部门有多个员工，如果公司CEO要下发通知给每个员工，是调用接口直接通知所有员工么？其实不然，CEO只需和它的“朋友”类部门Leader交流就好，部门Leader再下发通知信息即可。而CEO类不需要与员工进行“交流”。 6.合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。 五、设计模式的优点 设计原则是设计模式的提炼，因而设计原则的好处与设计模式是一致的，即：代码易于理解；更适于团体合作；适应需求变化等。 六、设计模式与设计原则 1.创建类设计模式 工厂模式：工厂方法模式是一种解耦结构，工厂类只需要知道抽象产品类，符合最少知识原则（迪米特法则）；同时符合依赖倒置原则和里氏替换原则； 抽象工厂模式：抽象工厂模式具有工厂模式的优点，但同时，如果产品族要扩展，工厂类也要修改，违反了开闭原则； 模板模式：优秀的扩展能力符合开闭原则。 2.结构类设计模式 代理模式：代理模式在业务逻辑中将对主体对象的操作进行封装，合适的应用会符合开闭原则和单一职责原则；事实上，几乎带有解耦作用的结构类设计模式都多少符合些开闭原则； 门面模式：门面模式不符合开闭原则，有时不符合单一职责原则，如若不注意，也会触碰接口隔离原则； 组合模式：符合开闭原则，但由于一般在拼接树时使用实现类，故不符合依赖倒置原则； 桥梁模式：桥梁模式堪称依赖倒置原则的典范，同时也符合开闭原则。 3.行为类设计模式 策略模式：符合开闭原则，但高层模块调用时，不符合迪米特法则。行为类设计模式多少会符合些单一职责原则，典型的如观察者模式、中介者模式、访问者模式等； 责任链模式：符合单一职责原则和迪米特法则； 命令模式：符合开闭原则。 在不同的业务逻辑中，不同的设计模式也会显示出不同的设计原则特点，从这个意义上来说，设计模式是设计原则的体现，但体现不是固定的，是根据业务而有所不同的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[]},{"title":"Git的使用","slug":"Git","date":"2018-12-02T19:06:24.563Z","updated":"2018-12-02T19:06:24.566Z","comments":true,"path":"2018/12/03/Git/","link":"","permalink":"http://yoursite.com/2018/12/03/Git/","excerpt":"简单地说，Git 究竟是怎样的一个系统呢？GIT是一种版本控制器，更直白的说，团队开发的时候，管理代码使用的软件。Git 有多种使用方式。你可以使用原生的命令行模式，也可以使用 GUI 模式，这些 GUI 软件也能提供多种功能。","text":"简单地说，Git 究竟是怎样的一个系统呢？GIT是一种版本控制器，更直白的说，团队开发的时候，管理代码使用的软件。Git 有多种使用方式。你可以使用原生的命令行模式，也可以使用 GUI 模式，这些 GUI 软件也能提供多种功能。 一、Git 基础1.安装Git 1.1在 Linux 上安装 1sudo yum install git 1.2在 Window 上安装 1访问 [Git官网](https://git-scm.com/) 下载windows版，一路“Next”完毕，安装成功！ 2.Git的配置 2.1 设置账户(需要和github账户设置一致,引号内的内容需要更改)12git config --global user.name \"your-name\" git config --global user.email \"your-email@163.com\" 2.2 查看设置123git config --listuser.name=&quot;your-name&quot;user.email=&quot;your-email@163.com&quot; 3.创建版本库(创建完文件夹,在该文件夹内启动git bash)123cd D:/mkdir mygitgit init 注意.git是一个隐藏的目录，该文件的不要乱动(每一次的操作，都会有记录)仓库建在中文目录下，可能出现问题 4.查看Git的状态1git status 一般来说会显示需要提交的文件(uncommited)和未追踪的文件(untracked) uncommited：已有的，刚被修改尚未提交的;untracked：原先没有的，新建的 5.添加文件至版本库的步骤12git add &lt;your_file_name&gt; # 将 your_file_name 文件保存在暂存区git commit -m \"add your explain for the file\" # 将 your_file_name 提交到版本库 6.Git删除文件（夹）12git rm your_file_name # 删除文件git rm -r folder # 删除文件夹 git rm和直接删除的区别在于git rm会将此文件的操作记录删除，而直接删除仅仅是删除了物理文件，没有删除和此文件相关的记录。git rm后会在版本库产生区别（有操作日志），而直接删除没有。 12git rm test.txt &gt;&gt;&gt; git commit -m 'delete a file'rm test.txt &gt;&gt;&gt; git commit -am 'delete a file' 注意：命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 二、Git 远程仓库之团队合作1.Git查看操作日志12345678git log # 查看项目日志git log file # 查看某个文件日志git log # 查看本目录日志git reflog # 查看详细做了啥git log --decorate --graph --oneline --all # 显示当前及之前的版本号git log --pretty=oneline # 将版本历史显示为一行，历史版本号全部显示git log --pretty=oneline --abbrev-commit # 将版本历史显示为一行，历史版本号部分显示git log --graph # 查看分支合并图 2.Git版本回退12git reset --hard \"head^^^\"git reset --hard 123abc --hard代表的是当前版本，后面的^符号代表的是退回到第几个版本，几个^符号就代表退回第几个;123abc代表的是版本号，保证版本号是唯一的即可 3.Git还原1git checkout -- myfile.md 4.Git分支1234git branch # 查看分支git branch dev # 创建分支git checkout dev # 切换分支git merge dev # 合并分支 5.Git远程仓库配置12345git remote git remote -v # 查看名称和详细地址git remote remove &lt;远程地址&gt; # 删除远程仓库git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt; # 添加远程仓库git remote rename &lt;旧名称&gt; &lt;新名称&gt; # 修改远程仓库 6.Git推送本地分支代码到远程仓库 6.1创建项目：12https地址:https://github.com/smart1san/smart1san.github.io.gitSSH地址: git@github.com:smart1san/smart1san.github.io.git 6.2将代码推到远程仓库12git remote add origin https://github.com/smart1san.git # 首先为本地库添加远程库git push origin master # 将本地的版本(默认是master)，推到代号为origin的远程库 7.Git团队合作 7.1需要clone一份代码到自己的本地1git clone https://github.com/smart1san/smart1san.github.io.git 7.2在本地创建和远程分支对应的分支1git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt; 7.3在本地分支完成任务后，可以试图用以下代码推送自己的修改1git push &lt;远程主机名&gt; &lt;本地分支名&gt; 7.4若推送失败，则表明远程分支比本地更新，需要先用git pull试图合并1git pull origin master 7.5若pull失败并提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令创建链接1git branch --set-upstream-to=&lt;远程主机名&gt;/&lt;远程分支名&gt; &lt;本地分支名&gt; 7.6若合并有冲突，则解决冲突，并在本地提交（add =&gt; commit）7.7在没有冲突或者解决掉冲突后，再用git push &lt;远程主机名&gt; &lt;本地分支名&gt;推送就能成功 三、配置公钥免密登录1.配置ssh格式的远程仓库1git remote add &lt;远程仓库名&gt; &lt;远程仓库地址&gt; 2.在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa(私钥)和id_rsa.pub(公钥)这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash）,执行下一步 windows位置：‪C:\\Users\\用户名.ssh\\id_rsa.pub Linux位置：cat ~/.ssh/id_rsa.pub 3.创建ssh key1ssh-keygen -t rsa -C \"youremail@163.com\" 4.获得key的内容，复制下来，添加到gitHub的SSH key中 4.1 settings4.2 SSH and GPG keys4.3 ADD SSH key","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Django基础知识","slug":"Django","date":"2018-12-02T16:29:39.037Z","updated":"2018-12-02T16:29:39.041Z","comments":true,"path":"2018/12/03/Django/","link":"","permalink":"http://yoursite.com/2018/12/03/Django/","excerpt":"Web框架（Web framework）是一种开发框架，用来支持动态网站、网络应用和网络服务的开发。这大多数的web框架提供了一套开发和部署网站的方式，也为web行为提供了一套通用的方法。Python的WEB框架有Django、Tornado、Flask 等多种，Django相较与其他WEB框架其优势为：大而全，框架本身集成了ORM、模型绑定、模板引擎、缓存、Session等诸多功能。","text":"Web框架（Web framework）是一种开发框架，用来支持动态网站、网络应用和网络服务的开发。这大多数的web框架提供了一套开发和部署网站的方式，也为web行为提供了一套通用的方法。Python的WEB框架有Django、Tornado、Flask 等多种，Django相较与其他WEB框架其优势为：大而全，框架本身集成了ORM、模型绑定、模板引擎、缓存、Session等诸多功能。 一、Django 简介1.Http 协议特性 TCP/IP协议之上的应用层协议 基于Request-Response模式 无状态保存 无连接 2.MVC和MTV① MVC M：Model（存取数据） V：View（取到数据展示给用户） C：Controller（分配工作给M和V） ② MTV M：Model（存取数据） T：Template（取到数据展示给用户） V：View（从M处取数据，返回给T） URL控制器 3.Django请求生命周期Browser — Web服务器（wsgi协议）— Middleware — URL路由 —View === ①从DataBase取数据；②将数据渲染至template 二、路由1.定义本质是URL与要为该URL调用的视图函数之间的映射表 2.简单路由配置123456from django.conf.urls import urlurlpatterns = [ url(r\"pattern\",views.视图函数,&#123;key:value&#125;,name=别名),]注意:urlpatterns从上至下逐行匹配,成功不再往下执行 3.有名分组123456789urlpatterns = [ url(\"index/(?P&lt;num&gt;pattern)\",views.index),]def index(request,num=1): print(num) return HttpResponse('ok') 注意：捕获的值作为关键字参数而不是位置参数传递给视图函数 4. 无名分组5.路由分发① 主URL 123456789from django.conf.urls import url,include# from django.urls import path,re_path,include // 2.+版本from app01 import viewsfrom app01 import urlsurlpatterns = [ path(&apos;app01/&apos;,include(&apos;app01.urls&apos;)), path(&apos;app01/&apos;, include(urls)),]注意:include() 括号中建议写app01.urls的方式,而不是直接写urls ② app01中的URL 12345from django.urls import path,re_path // 2.+版本from app01 import viewsurlpatterns = [ re_path(r\"pattern\",views.视图函数,&#123;key:value&#125;,name=别名),] 6.路由反向解析 应用:获得URL 的最终形式，用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。 ①urls.py 12345from django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ re_path(r\"有名分组\",views.视图函数,&#123;key:value&#125;,name=别名),] ②html代码 1&#123;% url &quot;别名&quot; 参数1 参数2 ... %&#125; ③视图函数 12url=reverse(&apos;test&apos;)url=reverse(&apos;test&apos;,args=(10,20)) 7.名称空间12由于name没有作用域，Django在反解URL时，会在项目全局顺序搜索，当查找到第一个name指定URL时，立即返回在开发项目时，会经常使用name属性反解出URL，当不小心在不同的app的urls中定义相同的name时，可能会导致URL反解错误，为了避免这种事情发生，引入了命名空间。 解决方式：在路由分发时，指定名称空间 12345urls.pyurlpatterns = [ url(r&apos;app01/&apos;,include(&apos;app01.urls&apos;,namespace=&apos;app01&apos;)), url(r&apos;app02/&apos;,include(&apos;app02.urls&apos;,namespace=&apos;app02&apos;))，] 123视图函数url=reverse(&apos;app02:index&apos;)url2=reverse(&apos;app01:index&apos;) 12模板&lt;a href=&quot;&#123;% url &apos;app02:index&apos;%&#125;&quot;&gt;LOL NB&lt;/a&gt; 8.Django 2.+版的path①模板 12345from django.urls import path from app01 import views urlpatterns = [ path(r'index/&lt;int:year&gt;/&lt;slug&gt;/', views.视图函数),] ②基本规则 使用尖括号(&lt;&gt;)从url中捕获值。 捕获值中可以包含一个转化器类型（converter type），比如使用 &lt;int:name&gt; 捕获一个整数变量。若果没有转化器，将匹配任何字符串，当然也包括了 / 字符。 无需添加前导斜杠。 ③path转换器 12345str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式int,匹配正整数，包含0slug,匹配字母、数字以及横杠、下划线组成的字符串uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？） ④自定义注册转换器 12345对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点： regex 类属性，字符串类型 to_python(self, value) 方法，value是由类属性 regex 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。 to_url(self, value) 方法，和 to_python 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。 自定义文件 app01/Myconverter.py 123456class MyConverter: regex = \"pattern\" def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value urls.py 12345678from django.urls import register_converter, path from app01 import converters, views ①注册register_converter(converters.MyConverter, 'type') ②使用urlpatterns = [ path('articles/&lt;type:year&gt;/', views.year_archive),] 三、视图1.三剑客123from django.shortcuts import render, HttpResponse, redirect视图层，熟练掌握两个对象即可：请求对象(request)和响应对象(HttpResponse) 2. HttpRequest对象 Django将请求报文中的请求行、首部信息、内容主体封装成 HttpRequest 类中的属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859request.GET 类似于字典的对象,包含 HTTP GET 的所有参数;QueryDict request.POST 类似于字典的对象,如果请求中包含表单数据,则将这些数据封装成 QueryDict 对象注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： request.POST.getlist(\"hobby\") request.body 一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST request.path 一个字符串，表示请求的路径组件（不含域名）。 例如：\"/music/bands/the_beatles/\" request.method 一个字符串，表示请求使用的HTTP 方法。必须使用大写。 request.FILES 一个类似于字典的对象，包含所有的上传文件信息。FILES 中的每个键为&lt;input type=\"file\" name=\"\" &gt; 中的name，值则为对应的数据。 # 注意，FILES 只有在请求的方法为POST 且提交的&lt;form&gt; 带有enctype=\"multipart/form-data\" 的情况下才会包含数据。否则，FILES 将为一个空的类似于字典的对象。 request.COOKIES 一个标准的Python 字典，包含所有的cookie。键和值都为字符串。 request.session 一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。--------------------------------------------------------request.encoding 一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。 这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。 接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。 若你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。 request.META 一个标准的 Python 字典，包含所有的 HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： 取值： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如\"GET\" 或\"POST\"。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时， 都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_ 前缀。 所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。 request.user(用户认证组件下使用) 一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。可以通过 is_authenticated() 区分它们。 request常用方法 123456789101112request.get_full_path() 返回 path，如果可以将加上查询字符串。 例如：\"/music/bands/the_beatles/?print=true\"request.path() 返回：/music/bands/the_beatles request.is_ajax() 若请求是通过 XMLHttpRequest 发起的,则返回 True,方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest' 大部分现代的 JavaScript 库都会发送这个头部。若自己编写的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。 3.HttpResponse 对象 响应三剑客 1from django.shortcuts import render, HttpResponse, redirect HttpResponse() 括号内直接跟上字符串作为响应体 render() 1234567render(request, template_name[, context]） request： 用于生成响应的请求对象。 template_name：要使用的模板的完整名称，可选的参数 context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。render方法就是将一个模板页面中的模板语法进行渲染，最终渲染成一个html页面作为响应体 redirect() 1跳转至指定的 URL 重定向301和302的异同点 1234567891011相同点：浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址不同点： 301表示旧地址A的资源已经被永久地移除了（该资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 重定向原因：（1）网站调整（如改变网页目录结构）；（2）网页被移到一个新地址；（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的 网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 4.JsonResponse123456789101112# 第一种方式# import json# data=&#123;'name':'lqz','age':18&#125;# data1=['lqz','egon']# return HttpResponse(json.dumps(data1))# 第二种方式from django.http import JsonResponsedata = &#123;'name': 'lqz', 'age': 18&#125;data1 = ['lqz', 'egon']return JsonResponse(data)return JsonResponse(data1,safe=False) # safe=True(默认) 表示只有字典才可以被序列化向前端返回一个json格式字符串的两种方式 5.CBV和FBV CBV:Class base view —基于类的视图 123456789101112131415from django.views import Viewclass AddPublish(View): def dispatch(self, request, *args, **kwargs): print(request) print(args) print(kwargs) # 可以写类似装饰器的东西，在前后加代码 obj=super().dispatch(request, *args, **kwargs) return obj def get(self,request): return render(request,'index.html') def post(self,request): request return HttpResponse('post') FBV:Function base view 基于函数的视图 123def index(request): pass return HttpResponse(\"hi\") 6.简单文件上传 html 文件 123456&lt;!--不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据--&gt;&lt;form action=\"\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\"&gt; &lt;button type=\"submit\"&gt;上传&lt;/button&gt;&lt;/form&gt; py 文件 123456789from django.core.files.uploadedfile import InMemoryUploadedFiledef index(request): print(request.FILES) print(type(request.FILES.get('file_name'))) file_name=request.FILES.get('file_name').name with open(file_name,'wb')as f: for i in request.FILES.get('file_name').chunks(): f.write(i) return HttpResponse(\"Ok\") 四、模板1.template.html1234&#123;&#123; 写非逻辑代码 &#125;&#125; ---变量&#123;% 写逻辑代码 %&#125; ---标签---if/for/extract服务器传到前端的数据(data)如果是字典的取值方式(深度查询): data.字段 2.过滤器123456789101112131415161718&#123;&#123; obj | filter__name:param &#125;&#125; 变量名 | 过滤器名:参数&#123;&#123; obj | safe &#125;&#125; 告诉浏览器是安全的,可以直接进行渲染,不必转义 xss攻击：跨站脚本攻击 可以在视图函数里处理 from django.utils.safestring import mark_safe obj=mark_safe(obj)&#123;&#123; value|default:\"nothing\" &#125;&#125; 变量是false或者为空,使用给定的默认值&#123;&#123; value|length &#125;&#125; 返回值的长度.它对字符串和列表都起作用&#123;&#123; value|filesizeformat &#125;&#125; 将值格式化为\"人类可读的\"文件尺寸&#123;&#123; value|date:\"Y-m-d\" &#125;&#125; 显示value的时间&#123;&#123; value|slice:\"2:-1\" &#125;&#125; 将value切分&#123;&#123; value|truncatechars:9 &#125;&#125; 如果字符串字符多于指定的字符数量,那么会被截断,截断的字符串将以可翻译的省略号序列（“...”）结尾&#123;&#123; value|truncatewords:2 &#125;&#125;其他过滤器：https://www.cnblogs.com/liuqingzheng/articles/9509806.html 3.标签123456789&#123;% empty %&#125; 只能在for循环当中使用//起别名&#123;% with total=business.employees.count %&#125; &#123;&#123; total &#125;&#125; employee&#123;&#123; total|pluralize &#125;&#125;&#123;% endwith %&#125;跨站请求伪造保护&#123;% csrf_token%&#125; 4.自定义templatetags1234567891011121314151617181920212223242526①在app01写创建templatetags目录(名字不可变动)②创建 my_tags.py 文件 from django import template from django.utils.safestring import mark_safe register=template.Library() //register 名字是固定的 // 自定义标签 // @register.simple_tag // def demo1(v1,v2): // return v1 * v2 @register.simple_tag def my_input(id,arg): result = \"&lt;input type='text'&gt;\" return mark_safe(result) // 自定义过滤器 @register.filter() def demo2(v1,v2): return v1 * v2③在使用自定义simple_tag和filter的html文件中导入之前创建的 my_tags.py &#123;% load my_tags %&#125; &#123;&#123; num|demo2:2 &#125;&#125; &#123;&#123; num|demo2:\"[22,333,4444]\" &#125;&#125; &#123;% demo1 2 5 %&#125; 参数不限,但不能放在if for语句中 &#123;% demo1i num 5 %&#125; ​ 注意：在settings.py中的INSTALLED_APPS配置当前app,不然Django无法找到自定义的simple_tag 5.模板导入和继承①导入 123&#123;% include 'template.html' %&#125;&#123;&#123; block.super &#125;&#125; // 复用模板的 block 组件 ②继承 模板 html 文件 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"/&gt; &lt;title&gt;&#123;% block title %&#125;My amazing site&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"sidebar\"&gt; &#123;% block sidebar %&#125; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/blog/\"&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &#123;% endblock %&#125;&lt;/div&gt;&lt;div id=\"content\"&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;base.html 定义了一个可以用于两列排版页面的简单HTML骨架。block 标签定义了三个可以被子模版内容填充的block。block 告诉模版引擎： 子模版可能会覆盖掉模版中的这些位置。 子模板 html 文件 12345678910111213&#123;% extends \"base.html\" %&#125; &#123;% block title %&#125;My amazing blog&#123;% endblock %&#125; &#123;% block content %&#125;&#123;% for entry in blog_entries %&#125; &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; entry.body &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% endblock %&#125;\"子模版\"的工作是用它们的内容填充空的blocks。extends 它告诉模版引擎，这个模版\"继承\"了另一个模版。当模版系统处理这个模版时,将定位父模板 base.html 使用继承的注意点 1234在模版中使用 &#123;% extends %&#125; 标签，它必须是模版中的第一个标签。其他的任何情况下，模版继承都将无法工作base模版中设置越多的 &#123;% block %&#125; 标签越好当你在大量的模版中复制内容,可能意味着你应该把内容移动到父模版中的一个 &#123;% block %&#125; 中给 &#123;% endblock name %&#125; 标签一个 name,具有更高的可读性 6.静态文件相关12&#123;% load static %&#125;&lt;img src=\"&#123;% static \"images/hi.jpg\" %&#125;\" alt=\"Hi!\" /&gt; 引用JS文件时使用 12&#123;% load static %&#125;&lt;script src=\"&#123;% static \"mytest.js\" %&#125;\"&gt;&lt;/script&gt; get_static_prefix 123456789&#123;% load static %&#125;&lt;img src=\"&#123;% get_static_prefix %&#125;images/hi.jpg\" alt=\"Hi!\" /&gt;or&#123;% load static %&#125;&#123;% get_static_prefix as STATIC_PREFIX %&#125;&lt;img src=\"&#123;&#123; STATIC_PREFIX &#125;&#125;images/hi.jpg\" alt=\"Hi!\" /&gt;&lt;img src=\"&#123;&#123; STATIC_PREFIX &#125;&#125;images/hi2.jpg\" alt=\"Hello!\" /&gt; 7.inclusion_tag 作用：返回 html 代码片段 templatetags / my_inclusion.py 12345678from django import templateregister = template.Library()@register.inclusion_tag('result.html')def show_results(n): n = 1 if n &lt; 1 else int(n) data = [\"第&#123;&#125;项\".format(i) for i in range(1, n+1)] return &#123;\"data\": data&#125; templates / snippets / result.html 12345&lt;ul&gt; &#123;% for choice in data %&#125; &lt;li&gt;&#123;&#123; choice &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; templates / index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;my_inclusion&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% load my_inclusion %&#125; &#123;% show_results 10 %&#125;&lt;/body&gt;&lt;/html&gt; 五、模型(models.py) 单表操作 ①创建表 ②字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151AutoField(Field) - int自增列，必须填入参数 primary_key=True BigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from django.db import models class UserInfo(models.Model): # 自动创建一个列名为id的且为自增的整数列 username = models.CharField(max_length=32) class Group(models.Model): # 自定义自增列 nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) SmallIntegerField(IntegerField): - 小整数 -32768 ～ 32767 PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正小整数 0 ～ 32767 IntegerField(Field) - 整数列(有符号的) -2147483648 ～ 2147483647 PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正整数 0 ～ 2147483647 BigIntegerField(IntegerField): - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807 自定义无符号整数字段 class UnsignedIntegerField(models.IntegerField): def db_type(self, connection): return 'integer UNSIGNED' PS: 返回值为字段在数据库中的属性，Django字段默认的值为： 'AutoField': 'integer AUTO_INCREMENT', 'BigAutoField': 'bigint AUTO_INCREMENT', 'BinaryField': 'longblob', 'BooleanField': 'bool', 'CharField': 'varchar(%(max_length)s)', 'CommaSeparatedIntegerField': 'varchar(%(max_length)s)', 'DateField': 'date', 'DateTimeField': 'datetime', 'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)', 'DurationField': 'bigint', 'FileField': 'varchar(%(max_length)s)', 'FilePathField': 'varchar(%(max_length)s)', 'FloatField': 'double precision', 'IntegerField': 'integer', 'BigIntegerField': 'bigint', 'IPAddressField': 'char(15)', 'GenericIPAddressField': 'char(39)', 'NullBooleanField': 'bool', 'OneToOneField': 'integer', 'PositiveIntegerField': 'integer UNSIGNED', 'PositiveSmallIntegerField': 'smallint UNSIGNED', 'SlugField': 'varchar(%(max_length)s)', 'SmallIntegerField': 'smallint', 'TextField': 'longtext', 'TimeField': 'time', 'UUIDField': 'char(32)', BooleanField(Field) - 布尔值类型 NullBooleanField(Field): - 可以为空的布尔值 CharField(Field) - 字符类型 - 必须提供max_length参数， max_length表示字符长度 TextField(Field) - 文本类型 EmailField(CharField)： - 字符串类型，Django Admin以及ModelForm中提供验证机制 IPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制 GenericIPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6 - 参数： protocol，用于指定Ipv4或Ipv6， 'both',\"ipv4\",\"ipv6\" unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启刺功能，需要protocol=\"both\" URLField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证 URL SlugField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号） CommaSeparatedIntegerField(CharField) - 字符串类型，格式必须为逗号分割的数字 UUIDField(Field) - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证 FilePathField(Field) - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能 - 参数： path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 FileField(Field) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage ImageField(FileField) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage width_field=None, 上传图片的高度保存的数据库字段名（字符串） height_field=None 上传图片的宽度保存的数据库字段名（字符串） DateTimeField(DateField) - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] DateField(DateTimeCheckMixin, Field) - 日期格式 YYYY-MM-DD TimeField(DateTimeCheckMixin, Field) - 时间格式 HH:MM[:ss[.uuuuuu]] DurationField(Field) - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型 FloatField(Field) - 浮点型 DecimalField(Field) - 10进制小数 - 参数： max_digits，小数总长度 decimal_places，小数位长度 BinaryField(Field) - 二进制类型字段 ③参数 12345678910111213141516171819202122232425262728(1)null 如果为 True，Django 将用 NULL 来在数据库中存储空值。 默认值是 False. (1)blank 如果为 True，该字段允许不填。默认为 False。要注意，这与 null 不同。null 纯粹是数据库范畴的，而 blank 是数据验证范畴的。如果一个字段的blank=True，表单的验证将允许该字段是空值。如果字段的blank=False，该字段就是必填的。 (2)default 字段的默认值。可以是一个值或者可调用对象。如果可调用 ，每有新对象被创建它都会被调用。 (3)primary_key 如果为True，那么这个字段就是模型的主键。如果你没有指定任何一个字段的primary_key=True，Django 就会自动添加一个IntegerField字段做为主键，所以除非你想覆盖默认的主键行为，否则没必要设置任何一个字段的primary_key=True。 (4)unique 如果该值设置为 True, 这个数据字段的值在整张表中必须是唯一的 (5)choices由二元组组成的一个可迭代对象（例如，列表或元组），用来给字段提供选择项。 如果设置了choices ，默认的表单将是一个选择框而不是标准的文本框，&lt;br&gt;而且这个选择框的选项就是choices 中的选项。参数 ④元信息 1234567891011121314151617181920class UserInfo(models.Model): nid = models.AutoField(primary_key=True) username = models.CharField(max_length=32) class Meta: # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名 db_table = \"table_name\" # 联合索引 index_together = [ (\"pub_date\", \"deadline\"), ] # 联合唯一索引 unique_together = ((\"driver\", \"restaurant\"),) # admin中显示的表名称 verbose_name # verbose_name加s verbose_name_plural ⑤增加删除字段 1234删除，直接注释掉字段，执行数据库迁移命令即可新增字段，在类里直接新增字段，直接执行数据库迁移命令会提示输入默认值，此时需要设置QuerySet_obj = models.CharField(max_length=12,default='xxx',null=True) ⑥添加表记录 123# create方法的返回值book_obj就是插入book表中的python葵花宝典这本书籍纪录对象QuerySet_obj=Book.objects.create(字段=value,pub_date=\"2012-12-12\")# 注意：时间格式必须是字符串 123obj=Book(字段=value,pub_date=\"2012-12-12\")obj.save()# 注意：该方法必须调用保存 ⑦查询表记录 12345678910111213141516171819202122232425&lt;1&gt; all(): 查询所有结果 &lt;2&gt; filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 &lt;3&gt; get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。 &lt;4&gt; exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 &lt;5&gt; order_by(*field): 对查询结果排序('-id') &lt;6&gt; reverse(): 对查询结果反向排序 &lt;8&gt; count(): 返回数据库中匹配查询(QuerySet)的对象数量。 &lt;9&gt; first(): 返回第一条记录 &lt;10&gt; last(): 返回最后一条记录 &lt;11&gt; exists(): 如果QuerySet包含数据，就返回True，否则返回False &lt;12&gt; values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列 model的实例化对象，而是一个可迭代的字典序列&lt;13&gt; values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 &lt;14&gt; distinct(): 从返回结果中剔除重复纪录 ⑧基于双下划线的模糊查询 12345678910Book.objects.filter(price__in=[100,200,300])Book.objects.filter(price__gt=100)Book.objects.filter(price__lt=100)Book.objects.filter(price__gte=100)Book.objects.filter(price__lte=100)Book.objects.filter(price__range=[100,200])Book.objects.filter(title__contains=\"python\")Book.objects.filter(title__icontains=\"python\")Book.objects.filter(title__startswith=\"py\")Book.objects.filter(pub_date__year=2012) ⑨删除表记录 12345678910111213model_obj.delete()它运行时立即删除对象而不返回任何值。---------------------------------------------------------可以一次性删除多个对象。每个 QuerySet 都有一个 delete() 方法，它一次性删除 QuerySet 中所有的对象。Entry.objects.filter(pub_date__year=2005).delete()# 注意： Django 2.+版本删除关联字段时，models.py 关联表中的关联字段必须设置 ON_DELETE=models.CASECADE 若不想级联删除，可设置 models.ForeignKey(to='Publisher', on_delete=models.SET_NULL, blank=True, null=True) delete() 方法是 QuerySet 上的方法，但并不适用于 Manager 本身。 ⑩修改表记录 123Book.objects.filter(title__startswith=\"py\").update(price=120） update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录update()方法会返回一个整型数值，表示受影响的记录条数。 多表操作 添加表记录①一对多 ②多对多 123456book_obj.authors.add(yuan,egon) book_obj.authors.remove() # 将某个特定的对象从被关联对象集合中去除。 ====== book_obj.authors.remove(*[])book_obj.authors.clear() #清空被关联对象集合book_obj.authors.set() #先清空再设置 跨表查询①一对一 123正向查询(按字段：authorDetail)obj=Author.objects.filter(name=\"xxx\").first()print(obj.authorDetail.telephone) 12345反向查询(按表名：author)# 查询所有住址在北京的作者的姓名authorDetail_list=AuthorDetail.objects.filter(addr=\"beijing\")for obj in authorDetail_list: print(obj.author.name) ②一对多 12345正向查询（按字段：publish）# 查询主键为1的书籍的出版社所在的城市book_obj=Book.objects.filter(pk=1).first()# book_obj.publish 是主键为1的书籍对象关联的出版社对象print(book_obj.publish.city) 123456反向查询（按表名：book_set）publish=Publish.objects.get(name=\"苹果出版社\")#publish.book_set.all() : 与苹果出版社关联的所有书籍对象集合book_list=publish.book_set.all() for book_obj in book_list: print(book_obj.title) ③多对多 123456正向查询(按字段：authors)# 所有作者的名字以及手机号book_obj=Book.objects.filter(title=\"眉\").first()authors=book_obj.authors.all()for author_obj in authors: print(author_obj.name,author_obj.authorDetail.telephone) 1234567反向查询(按表名：book_set)# 查询xxx出过的所有书籍的名字 author_obj=Author.objects.get(name=\"xxx\")book_list=author_obj.book_set.all() for book_obj in book_list: print(book_obj.title) 1234567# 注意：可通过在 ForeignKey() 和ManyToManyField的定义中设置 related_name 的值来覆写 FOO_set 的名称。publish = ForeignKey(Book, related_name='bookList')# 查询 人民出版社出版过的所有书籍publish=Publish.objects.get(name=\"人民出版社\")book_list=publish.bookList.all() # 与人民出版社关联的所有书籍对象集合 双下滑下跨表查询①一对多 12# 正向查询 按字段:publishqueryResult=Book.objects.filter(publish__name=\"苹果出版社\").values_list(\"title\",\"price\") 12# 反向查询 按表名:bookqueryResult=Publish.objects.filter(name=\"苹果出版 社\").values_list(\"book__title\",\"book__price\") ②多对多 12# 正向查询 按字段:authors:queryResult=Book.objects.filter(authors__name=\"xxx\").values_list(\"title\") 12# 反向查询 按表名:bookqueryResult=Author.objects.filter(name=\"xxx\").values_list(\"book__title\",\"book__price\") ③一对一 12# 正向查询ret=Author.objects.filter(name=\"xxx\").values(\"authordetail__telephone\") 12# 反向查询ret=AuthorDetail.objects.filter(author__name=\"alex\").values(\"telephone\") 聚合查询和分组查询 aggregate(*args,**kwargs) 12345# 计算所有图书的平均价格from django.db.models import Avg,Max, MinBook.objects.all().aggregate(Avg('price'))Book.objects.aggregate(Avg('price'), Max('price'), Min('price')) annotate() 123annotate()为调用的QuerySet中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。总结 ：跨表分组查询本质就是将关联表join成一张表，再按单表的思路进行分组查询。 F查询和Q查询1234567891011from django.db.models import FDjango 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。# 查询评论数大于收藏数的书籍Book.objects.filter(commnetNum__lt=F('keepNum'))Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。# 查询评论数大于收藏数2倍的书籍Book.objects.filter(commnetNum__lt=F('keepNum')*2)修改操作也可以使用F函数,比如将每一本书的价格提高30元Book.objects.all().update(price=F(\"price\")+30) 123from django.db.models import QQ 对象可以使用 &amp; 和 | 操作符组合起来。当一个操作符在两个 Q 对象上使用时，它产生一个新的 Q 对象。bookList=Book.objects.filter(Q(authors__name=\"a\")|Q(authors__name=\"b\")) 六、组件1.Ajax 定义 AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML,现在更多使用json数据）。 ​ 特点：①异步交互—客户端发出请求后,无需等待服务器响应结束,就可以发出第二个请求 ; ②浏览器页面局部刷新 ​ 优点：①使用Javascript技术向服务器发送异步请求②无须刷新整个页面 XMLHttpResponse 方式 12345XMLHttpResponse: ① 生成对象 ② 处理数据 ③ 发送数据 ④ 监听事件 Django 方式（常用） 12345678910ajax(&#123; // 是JQuery最底层的实现原理 url:\"\", type:\"\", data:&#123;&#125;, // dataType:\"json\", //client 向 server指定接收的数据类型 // contentType:\"\", //告诉jQuery不要去设置Content-Type请求头 // processData:boolean，// 告诉浏览器是否处理数据 // data.parse() // 将数据解析成指定格式 // data.Jsonify() // 将接接收的数据变成json类型&#125;) 应用场景:登录验证 文件上传 ①ContentType请求头 12application/x-www-form-urlencoded最常见的 POST 提交数据的方式了。浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据 12multipart/form-data常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data 12application/json用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 基于Form表单上传文件 html 文件 12345&lt;form action=\"/file_put/\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名：&lt;input type=\"text\" name=\"name\"&gt; 头像：&lt;input type=\"file\" name=\"avatar\" id=\"avatar1\"&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; py文件视图函数 12345678910111213141516def file_put(request): if request.method=='GET': return render(request,'file_put.html') else: print(request.body) # 原始的请求体数据 print(request.GET) # GET请求数据 print(request.POST) # POST请求数据 print(request.FILES) # 上传的文件数据 print(request.body.decode('utf-8')) file_obj=request.FILES.get('avatar') print(type(file_obj)) with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('ok') 基于Ajax上传 1234567891011121314151617$(\"#ajax_button\").click(function () &#123; var formdata=new FormData() formdata.append('name',$(\"#id_name2\").val()) formdata.append('avatar',$(\"#avatar2\")[0].files[0]) $.ajax(&#123; url:'', type:'post', processData:false, //告诉jQuery不要去处理发送的数据 contentType:false,// 告诉jQuery不要去设置Content-Type请求头 data:formdata, success:function (data) &#123; console.log(data) &#125; &#125;)&#125;) Ajax提交json格式的数据 12345678910111213141516 $(\"#ajax_test\").click(function () &#123; var dic=&#123;'name':'lqz','age':18&#125; $.ajax(&#123; url:'', type:'post', contentType:'application/json', //一定要指定格式 contentType: 'application/json;charset=utf-8', data:JSON.stringify(dic), //转换成json字符串格式 success:function (data) &#123; console.log(data) &#125; &#125;) &#125;)提交到服务器的数据都在 request.body 里，取出来自行处理 2.分页器12345678910111213141516from django.core.paginator import Paginator,EmptyPage, PageNotAnIntegerPaginator对象： paginator = Paginator(user_list, 10)# paginator.per_page: 每页显示条目数量# paginator.count: 数据总个数# paginator.num_pages: 总页数# paginator.page_range:总页数的索引范围，如: (1,10),(1,200)# paginator.page: page对象 page对象：page=paginator.page(1) #第1页的page对象# page1.has_next 是否有下一页# page1.next_page_number 下一页页码# page1.has_previous 是否有上一页# page1.previous_page_number 上一页页码# page1.object_list 分页之后的数据列表# page1.number 当前页# page1.paginator paginator对象 批量导入数据 1234Booklist=[]for i in range(100): Booklist.append(Book(title=\"book\"+str(i),price=30+i*i))Book.objects.bulk_create(Booklist) View视图函数 123456789101112131415161718from django.shortcuts import render,HttpResponsefrom app01.models import *from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger# Create your views here.def index(request): book_list=Book.objects.all() paginator = Paginator(book_list, 10) page = request.GET.get('page',1) # 从客户端传过来的所显示的当前页面 currentPage=int(page) try: print(page) book_list = paginator.page(page) except PageNotAnInteger: book_list = paginator.page(1) except EmptyPage: book_list = paginator.page(paginator.num_pages) return render(request,\"index.html\",&#123;\"book_list\":book_list,\"paginator\":paginator,\"currentPage\":currentPage&#125;) 模板层 index.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h4&gt;分页器&lt;/h4&gt; &lt;ul&gt; &#123;% for book in book_list %&#125; &lt;li&gt;&#123;&#123; book.title &#125;&#125; -----&#123;&#123; book.price &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;ul class=\"pagination\" id=\"pager\"&gt; &#123;% if book_list.has_previous %&#125; &lt;li class=\"previous\"&gt;&lt;a href=\"/index/?page=&#123;&#123; book_list.previous_page_number &#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"previous disabled\"&gt;&lt;a href=\"#\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for num in paginator.page_range %&#125; &#123;% if num == currentPage %&#125; &lt;li class=\"item active\"&gt;&lt;a href=\"/index/?page=&#123;&#123; num &#125;&#125;\"&gt;&#123;&#123; num &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"item\"&gt;&lt;a href=\"/index/?page=&#123;&#123; num &#125;&#125;\"&gt;&#123;&#123; num &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if book_list.has_next %&#125; &lt;li class=\"next\"&gt;&lt;a href=\"/index/?page=&#123;&#123; book_list.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"next disabled\"&gt;&lt;a href=\"#\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 核心逻辑 12345678910显示左5，右5，总共11个页，1 如果总页码大于11 1.1 if 当前页码减5小于1，要生成1到12的列表（顾头不顾尾，共11个页码） page_range=range(1,12) 1.2 elif 当前页码+5大于总页码，生成当前页码减10，到当前页码加1的列表（顾头不顾尾，共11个页码） page_range=range(paginator.num_pages-10,paginator.num_pages+1) 1.3 else 生成当前页码-5，到当前页码+6的列表 page_range=range(current_page_num-5,current_page_num+6)2 其它情况，生成的列表就是pageinator的page_range page_range=paginator.page_range 123456789101112131415161718192021222324252627def index(request): book_list=Book.objects.all() paginator = Paginator(book_list, 15) page = request.GET.get('page',1) currentPage=int(page) # 如果页数十分多时，换另外一种显示方式 if paginator.num_pages&gt;11: if currentPage-5&lt;1: pageRange=range(1,11) elif currentPage+5&gt;paginator.num_pages: pageRange=range(currentPage-5,paginator.num_pages+1) else: pageRange=range(currentPage-5,currentPage+5) else: pageRange=paginator.page_range try: print(page) book_list = paginator.page(page) except PageNotAnInteger: book_list = paginator.page(1) except EmptyPage: book_list = paginator.page(paginator.num_pages) return render(request,\"index.html\",locals()) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.min.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &#123;% for foo in page %&#125; &lt;li&gt;&#123;&#123; foo.name &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &#123;% if page.has_previous %&#125; &lt;li&gt; &lt;a href=\"/page_test/?page=&#123;&#123; page.previous_page_number &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt; &lt;a href=\"#\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% for foo in page_range %&#125; &#123;% if current_page == foo %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"/page_test/?page=&#123;&#123; foo &#125;&#125;\"&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/page_test/?page=&#123;&#123; foo &#125;&#125;\"&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;li&gt; &lt;a href=\"/page_test/?page=&#123;&#123; page.next_page_number &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt; &lt;a href=\"#\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 3.forms组件 校验字段（如用户注册） 123456models.pyclass UserInfo(models.Model): name=models.CharField(max_length=32) pwd=models.CharField(max_length=32) email=models.EmailField() 123456789101112131415161718192021222324252627282930313233模板文件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;div&gt; &lt;label for=\"user\"&gt;用户名&lt;/label&gt; &lt;p&gt;&lt;input type=\"text\" name=\"name\" id=\"name\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"pwd\"&gt;密码&lt;/label&gt; &lt;p&gt;&lt;input type=\"password\" name=\"pwd\" id=\"pwd\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"r_pwd\"&gt;确认密码&lt;/label&gt; &lt;p&gt;&lt;input type=\"password\" name=\"r_pwd\" id=\"r_pwd\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"email\"&gt;邮箱&lt;/label&gt; &lt;p&gt;&lt;input type=\"text\" name=\"email\" id=\"email\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132视图函数# forms组件from django.forms import widgetswid_01=widgets.TextInput(attrs=&#123;\"class\":\"form-control\"&#125;)wid_02=widgets.PasswordInput(attrs=&#123;\"class\":\"form-control\"&#125;)class UserForm(forms.Form): name=forms.CharField(max_length=32, widget=wid_01 ) pwd=forms.CharField(max_length=32,widget=wid_02) r_pwd=forms.CharField(max_length=32,widget=wid_02) email=forms.EmailField(widget=wid_01) tel=forms.CharField(max_length=32,widget=wid_01)def register(request): # 此时 request.POST 字典中的数据是未验证过的证据 if request.method==\"POST\": form=UserForm(request.POST) # 验证符合之后的字典形式数据 if form.is_valid(): print(form.cleaned_data) # 所有干净的字段以及对应的值 else: print(form.cleaned_data) print(form.errors.get(\"__all__\")) print(form.errors) # ErrorDict : &#123;\"校验错误的字段\":[\"错误信息\",]&#125; print(form.errors.get(\"name\")) # ErrorList [\"错误信息\",] return HttpResponse(\"OK\") form=UserForm() return render(request,\"register.html\",locals()) 渲染标签 ①方式一（拓展性高） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;注册页面&lt;/h3&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-lg-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;div&gt; &lt;label for=\"\"&gt;用户名&lt;/label&gt; &#123;&#123; form.name &#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label for=\"\"&gt;密码&lt;/label&gt; &#123;&#123; form.pwd &#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label for=\"\"&gt;确认密码&lt;/label&gt; &#123;&#123; form.r_pwd &#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label for=\"\"&gt; 邮箱&lt;/label&gt; &#123;&#123; form.email &#125;&#125; &lt;/div&gt; &lt;input type=\"submit\" class=\"btn btn-default pull-right\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ②方式二（推荐） 123456789&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;div&gt; &lt;label for=\"\"&gt;&#123;&#123; field.label &#125;&#125;&lt;/label&gt; &#123;&#123; field &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" class=\"btn btn-default pull-right\"&gt;&lt;/form&gt; ③方式三 123456&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125; &lt;!-- 直接全部当成p标签渲染 --&gt; &lt;input type=\"submit\" class=\"btn btn-default pull-right\"&gt;&lt;/form&gt; 校验不通过错误信息渲染 1234567891011121314Views.pydef register(request): if request.method==\"POST\": form=UserForm(request.POST) if form.is_valid(): print(form.cleaned_data) # 所有干净的字段以及对应的值 else: print(form.cleaned_data) # print(form.errors) # ErrorDict : &#123;\"校验错误的字段\":[\"错误信息\",]&#125; print(form.errors.get(\"name\")) # ErrorList [\"错误信息\",] return render(request,\"register.html\",locals()) form=UserForm() return render(request,\"register.html\",locals()) 12345678910111213index.html&lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;div&gt; &lt;label for=\"\"&gt;&#123;&#123; field.label &#125;&#125;&lt;/label&gt; &#123;&#123; field &#125;&#125; &lt;span class=\"pull-right\" style=\"color: red\"&gt;&#123;&#123; field.errors.0 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" class=\"btn btn-default\"&gt;&lt;/form&gt; 组件参数设置 1234567class Ret(Form): # 这里有label之后,html中可以不用写label标签,可以添加错误信息,也可以控制组件的属性 name = forms.CharField(max_length=10, min_length=2, label='用户名', error_messages=&#123;'required': '该字段不能为空', 'invalid': '格式错误', 'max_length': '太长','min_length': '太短'&#125;, widget=widgets.TextInput(attrs=&#123;'class':'form-control'&#125;)) pwd = forms.CharField(max_length=10, min_length=2, widget=widgets.PasswordInput(attrs= &#123;'class':'form-control'&#125;)) email = forms.EmailField(label='邮箱', error_messages=&#123;'required': '该字段不能为空', 'invalid': '格式错误'&#125;) 局部钩子（校验字段） 123456789101112131415161718from django.core.exceptions import NON_FIELD_ERRORS, ValidationErrordef clean_name(self): val=self.cleaned_data.get(\"name\") ret=UserInfo.objects.filter(name=val) if not ret: return val else: raise ValidationError(\"该用户已注册!\") def clean_tel(self): val=self.cleaned_data.get(\"tel\") if len(val)==11: return val else: raise ValidationError(\"手机号格式错误\") 全局钩子（校验两次密码） 123456789101112def clean(self): pwd=self.cleaned_data.get('pwd') r_pwd=self.cleaned_data.get('r_pwd') if pwd and r_pwd: if pwd==r_pwd: return self.cleaned_data else: raise ValidationError('两次密码不一致') else: return self.cleaned_data 全部文件 ①自定义forms组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from django import formsfrom django.forms import widgetsfrom app01.models import UserInfofrom django.core.exceptions import NON_FIELD_ERRORS, ValidationErrorclass UserForm(forms.Form): name=forms.CharField(min_length=4,label=\"用户名\",error_messages=&#123;\"required\":\"该字段不能为空\"&#125;, widget=widgets.TextInput(attrs=&#123;\"class\":\"form-control\"&#125;) ) pwd=forms.CharField(min_length=4,label=\"密码\", widget=widgets.PasswordInput(attrs=&#123;\"class\":\"form-control\"&#125;) ) r_pwd=forms.CharField(min_length=4,label=\"确认密码\",error_messages=&#123;\"required\":\"该字段不能为空\"&#125;,widget=widgets.TextInput(attrs=&#123;\"class\":\"form-control\"&#125;)) email=forms.EmailField(label=\"邮箱\",error_messages=&#123;\"required\":\"该字段不能为空\",\"invalid\":\"格式错误\"&#125;,widget=widgets.TextInput(attrs=&#123;\"class\":\"form-control\"&#125;)) tel=forms.CharField(label=\"手机号\",widget=widgets.TextInput(attrs=&#123;\"class\":\"form-control\"&#125;)) def clean_name(self): val=self.cleaned_data.get(\"name\") ret=UserInfo.objects.filter(name=val) if not ret: return val else: raise ValidationError(\"该用户已注册!\") def clean_tel(self): val=self.cleaned_data.get(\"tel\") if len(val)==11: return val else: raise ValidationError(\"手机号格式错误\") def clean(self): pwd=self.cleaned_data.get('pwd') r_pwd=self.cleaned_data.get('r_pwd') if pwd and r_pwd: if pwd==r_pwd: return self.cleaned_data else: raise ValidationError('两次密码不一致') else: return self.cleaned_data ②视图函数 12345678910111213141516171819202122232425262728293031323334353637from django.shortcuts import render,HttpResponsefrom app01.myforms import *# Create your views here.def reg(request): if request.method==\"POST\": print(request.POST) #form=UserForm(&#123;\"name\":\"yu\",\"email\":\"123@qq.com\",\"xxxx\":\"alex\"&#125;) form=UserForm(request.POST) # form表单的name属性值应该与forms组件字段名称一致 print(form.is_valid()) # 返回布尔值 if form.is_valid(): print(form.cleaned_data) # &#123;\"name\":\"yuan\",\"email\":\"123@qq.com\"&#125; else: print(form.cleaned_data) # &#123;\"email\":\"123@qq.com\"&#125; # print(form.errors) # &#123;\"name\":[\"..........\"]&#125; # print(type(form.errors)) # ErrorDict # print(form.errors.get(\"name\")) # print(type(form.errors.get(\"name\"))) # ErrorList # print(form.errors.get(\"name\")[0]) # 全局钩子错误 #print(\"error\",form.errors.get(\"__all__\")[0]) errors=form.errors.get(\"__all__\") return render(request,\"reg.html\",locals()) ''' form.is_valid() :返回布尔值 form.cleaned_data :&#123;\"name\":\"yuan\",\"email\":\"123@qq.com\"&#125; form.errors :&#123;\"name\":[\"..........\"]&#125; ''' form=UserForm() return render(request,\"reg.html\",locals()) ③模板文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .error&#123; color: red; &#125; &lt;/style&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-lg-offset-3\"&gt; &#123;#&lt;h3&gt;简单form&lt;/h3&gt;#&#125; &#123;##&#125; &#123;##&#125; &#123;#&lt;form action=\"\" method=\"post\" novalidate&gt;#&#125; &#123;# &#123;% csrf_token %&#125;#&#125; &#123;# &lt;p&gt;用户名&lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt;#&#125; &#123;# &lt;p&gt;密码 &lt;input type=\"text\" name=\"pwd\"&gt;&lt;/p&gt;#&#125; &#123;# &lt;p&gt;确认密码 &lt;input type=\"text\" name=\"r_pwd\"&gt;&lt;/p&gt;#&#125; &#123;# &lt;p&gt;邮箱 &lt;input type=\"text\" name=\"email\"&gt;&lt;/p&gt;#&#125; &#123;# &lt;p&gt;手机号 &lt;input type=\"text\" name=\"tel\"&gt;&lt;/p&gt;#&#125; &#123;# &lt;input type=\"submit\"&gt;#&#125; &#123;##&#125; &#123;#&lt;/form&gt;#&#125; &lt;hr&gt; &lt;h3&gt;forms组件渲染方式1&lt;/h3&gt; &lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% csrf_token %&#125; &lt;p&gt;&#123;&#123; form.name.label &#125;&#125; &#123;&#123; form.name &#125;&#125; &lt;span class=\"pull-right error\"&gt;&#123;&#123; form.name.errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; form.pwd.label &#125;&#125; &#123;&#123; form.pwd &#125;&#125; &lt;span class=\"pull-right error\"&gt;&#123;&#123; form.pwd.errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;确认密码 &#123;&#123; form.r_pwd &#125;&#125; &lt;span class=\"pull-right error\"&gt;&#123;&#123; form.r_pwd.errors.0 &#125;&#125;&lt;/span&gt;&lt;span class=\"pull-right error\"&gt;&#123;&#123; errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;邮箱 &#123;&#123; form.email &#125;&#125; &lt;span class=\"pull-right error\"&gt;&#123;&#123; form.email.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;手机号 &#123;&#123; form.tel &#125;&#125; &lt;span class=\"pull-right error\"&gt;&#123;&#123; form.tel.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &#123;#&lt;h3&gt;forms组件渲染方式2&lt;/h3&gt;#&#125; &#123;##&#125; &#123;#&lt;form action=\"\" method=\"post\" novalidate&gt;#&#125; &#123;# &#123;% csrf_token %&#125;#&#125; &#123;##&#125; &#123;# &#123;% for field in form %&#125;#&#125; &#123;##&#125; &#123;# &lt;div&gt;#&#125; &#123;# &lt;label for=\"\"&gt;&#123;&#123; field.label &#125;&#125;&lt;/label&gt;#&#125; &#123;# &#123;&#123; field &#125;&#125;#&#125; &#123;# &lt;/div&gt;#&#125; &#123;##&#125; &#123;# &#123;% endfor %&#125;#&#125; &#123;##&#125; &#123;# &lt;input type=\"submit\"&gt;#&#125; &#123;#&lt;/form&gt;#&#125; &#123;##&#125; &#123;#&lt;h3&gt;forms组件渲染方式3&lt;/h3&gt;#&#125; &#123;##&#125; &#123;#&lt;form action=\"\" method=\"post\"&gt;#&#125; &#123;# &#123;% csrf_token %&#125;#&#125; &#123;##&#125; &#123;# &#123;&#123; form.as_p &#125;&#125;#&#125; &#123;##&#125; &#123;# &lt;input type=\"submit\"&gt;#&#125; &#123;#&lt;/form&gt;#&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4.cookie和session COOKIE 123456789101112Cookie：保存在浏览器端的键值对（应用：登录认证）Cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。----------------------------------------------------------obj=HttpResponse() 存cookie: obj.set_cookie(key,value,max_age(IE浏览器版本低不认识)/expires) obj.set_signed_cookie() # 设置加密方式的cookie; 删除COOKIE:obj.delete_cookie() # 删除用户浏览器上之前设置的usercookie值 取COOKIE：request.COOKIES.get(key) request.get_signed_cookie() # 敏感信息还是在前端可以看到----------------------------------------------------------csrf_token 也是在cookie中的，客户端/服务端均可设置 1234Cookie规范 Cookie大小上限为4KB； 一个服务器最多在客户端浏览器上保存20个Cookie； 一个浏览器最多保存300个Cookie； 12345678910cookie参数 ①key, 键 ②value=&apos;&apos;, 值 ④max_age=None, 超时时间 cookie需要延续的时间（以秒为单位）如果参数是\\ None`` ，这个cookie会延续到浏览器关闭为止 ⑤expires=None, 超时时间(IE requires expires, so set it if hasn&apos;t been already.) ⑥path=&apos;/&apos;, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将cookie传给站点中的其他的应用。 ⑦domain=None, Cookie生效的域名 你可用这个参数来构造一个跨站cookie。如， domain=&quot;.example.com&quot;所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 None ，cookie只能由设置它的站点读取 ⑧secure=False, 浏览器将通过HTTPS来回传cookie ⑨httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 123456789101112131415161718192021222324252627282930313233Cookie登录检验+装饰器def login_auth(func): def inner(request,*args,**kwargs): next_url=request.get_full_path() if request.COOKIES.get('is_login'): return func(request,*args,**kwargs) else: return redirect('cookie_login/?next=%s'%next_url) return inner@login_authdef cookie_order(request): return HttpResponse('我是订单页面')@login_authdef cookie_index(request): name=request.COOKIES.get('username') return render(request,'cookie_index.html',&#123;'name':name&#125;)def cookie_login(request): if request.method =='POST': next_url=request.GET.get('next') name=request.POST.get('name') password=request.POST.get('password') if name == 'lqz' and password == '123': import datetime now=datetime.datetime.now().strftime('%Y-%m-%d %X') print(now) obj=redirect(next_url) obj.set_cookie('is_login',True) obj.set_cookie('username',name) obj.set_cookie('login_time',now) return obj return render(request, 'cookie_login.html') session 1234567891011121314151617181920Session（字典的操作session基本都满足）：保存在服务端的键值对,内部机制依赖于cookieSession一般在很多页面都需要用到,所有可以用装饰器的方式来对多个函数进行装饰,减少重复代码存：request.session[key]=value取：request.session.get(key) request.session.iterkeys(), 不会直接取出值,只会在循环迭代时取值 request.session.session_key, 当前用户session的随机字符串 request.session.clear_expired(), 清除所有session已过期的数据 request.session.exists(\"key\"), 检查当期那用户session是否在数据库中 request.session.delete(\"key\"), 删除当前用户session数据 清除除session：request.session.clear() # 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems() 12345678910111213141516171819202122232425262728settings.py1. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认）2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎其他公用设置项：SESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ \"/\" # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） CBV 加装饰器 12345678910111213141516from django import viewsfrom django.utils.decorators import method_decorator# @method_decorator(login_auth,name='get')# @method_decorator(login_auth,name='post')class UserList(views.View): # @method_decorator(login_auth) def dispatch(self, request, *args, **kwargs): obj=super().dispatch(request, *args, **kwargs) return obj @method_decorator(login_auth) def get(self,request): return HttpResponse('我是用户列表') def post(self,request): return HttpResponse('我是用户列表') 5.中间件1中间件，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。 settings.py 12345678MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 自定义中间件（MyMiddlewares.py） 1234567891011121314151617181920from django.utils.deprecation import MiddlewareMixinfrom django.shortcuts import HttpResponseclass MyMiddleware1(MiddlewareMixin): def process_request(self,request): print(\"MyMiddleware1请求\") def process_response(self,request,response): print(\"MyMiddleware1返回\") return responseclass MyMiddleware2(MiddlewareMixin): def process_request(self,request): print(\"MyMiddleware2请求\") #return HttpResponse(\"Md2中断\") def process_response(self,request,response): print(\"MyMiddleware2返回\") return response views.py 123def index(request): print(\"view函数...\") return HttpResponse(\"OK\") settins.py中注册自定义中间件 12345MIDDLEWARE = [ \"...\", \"MyMiddlewares.MyMiddleware1\", \"MyMiddlewares.MyMiddleware2\",] 中间件中的几个方法（主要用到request和response） 123456789process_request(self,request)process_view(self, request, callback, callback_args, callback_kwargs)process_template_response(self,request,response)process_exception(self, request, exception)process_response(self, request, response) 中间件和视图函数的联系 123456 中间件的process_request方法是在执行视图函数之前执行的。 当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。 不同中间件之间传递的request都是同一个对象 总结： 多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。 中间件的应用 ① IP频率限制 1某些IP访问服务器的频率过高，进行拦截，比如限制每分钟不能超过20次。 ② URL访问过滤 123456假设用户访问的是login视图（可以通过）但是访问其他视图，需要检测是不是有session认证，已经有了放行，没有返回login，这样就省得在多个视图函数上写装饰器了！&apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,&apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, CSRF_TOKEN跨站请求伪造 定义 1一种对网站的恶意利用，尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性 CSRF攻击防范 ①方式一：验证 HTTP Referer 字段 12345 在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。若 Referer 中记录的不是指向自己网站，则认为是 CSRF 攻击，拒绝该访问。优点： 简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。缺点： Referer 值会记录用户的访问来源，用户认为这样会侵犯到隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 ②方式二：在请求地址中添加 token 并验证 1234这种方法要比检查 Referer 要安全一些，token 可以在用户登录后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 ③方式三：在 HTTP 头中自定义属性并验证 1这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 6.Auth模块（Django自带的用户认证模块）1from django.contrib import auth authenticate() 12user = authenticate(username=&apos;usernamer&apos;,password=&apos;password&apos;)用户认证功能，即验证用户名以及密码是否正确，一般需要username 、password两个关键字参数。认证成功（用户名和密码正确有效），便会返回一个 User 对象。authenticate()会在该 User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。 login(HttpRequest, user) 1函数接受一个HttpRequest对象，以及一个经过认证的User对象。实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据。 12345678910111213from django.contrib.auth import authenticate, login def my_view(request): username = request.POST['username'] password = request.POST['password'] user = authenticate(username=username, password=password) if user is not None: login(request, user) # Redirect to a success page. ... else: # Return an 'invalid login' error message. ... logout(request) 1函数接受一个HttpRequest对象，无返回值。用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。 12345from django.contrib.auth import logout def logout_view(request): logout(request) # Redirect to a success page. is_authenticated() 1用来判断当前请求是否通过了认证。 123def my_view(request): if not request.user.is_authenticated(): return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path)) login_requierd() 123456auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。若用户没有登录，则会跳转到django默认的 登录URL &apos;/accounts/login/ &apos; 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。LOGIN_URL = &apos;/login/&apos; # 这里配置成你项目登录页面的路由 12345from django.contrib.auth.decorators import login_required @login_requireddef my_view(request): ... create_user() 1auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。 12from django.contrib.auth.models import Useruser = User.objects.create_user（username='用户名',password='密码',email='邮箱',...） create_superuser() 1auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。 12from django.contrib.auth.models import Useruser = User.objects.create_superuser（username='用户名',password='密码',email='邮箱',...） check_password(password) 1auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。密码正确返回True，否则返回False。 1res = user.check_password('密码') set_password(password) 1234auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。&lt;!-- 注意 --&gt;设置完一定要调用用户对象的save方法！！！ 123456789101112131415161718192021222324@login_requireddef set_password(request): user = request.user err_msg = '' if request.method == 'POST': old_password = request.POST.get('old_password', '') new_password = request.POST.get('new_password', '') repeat_password = request.POST.get('repeat_password', '') # 检查旧密码是否正确 if user.check_password(old_password): if not new_password: err_msg = '新密码不能为空' elif new_password != repeat_password: err_msg = '两次密码不一致' else: user.set_password(new_password) # 设置密码 user.save() # 一定要保存 return redirect(\"/login/\") else: err_msg = '原密码输入错误' content = &#123; 'err_msg': err_msg, &#125; return render(request, 'set_password.html', content) User对象的属性 1234User对象属性：username， passwordis_staff ： 用户是否拥有网站的管理权限.is_active ： 是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。 扩展auth_user表 自定义Model类，继承AbstractUser类，又能使用Django强大的认证系统了 123456789101112131415from django.contrib.auth.models import AbstractUserclass UserInfo(AbstractUser): \"\"\"用户信息表\"\"\" nid = models.AutoField(primary_key=True) phone = models.CharField(max_length=11, null=True, unique=True) def __str__(self): return self.username # 注意 扩展了内置的auth_user表之后，一定要在settings.py中告诉Django，我现在使用我新定义的UserInfo表来做用户认证。 一旦我们指定了新的认证系统所使用的表，我们就需要重新在数据库中创建该表，而不能继续使用原来默认的auth_user表了。# 引用Django自带的User表，继承使用时需要设置AUTH_USER_MODEL = \"app名.UserInfo\" 7.ContentType（Django提供的ContentType表 ） models.py 12345678910111213141516171819202122232425from django.db import modelsfrom django.contrib.contenttypes.models import ContentTypefrom django.contrib.contenttypes.fields import GenericForeignKey, GenericRelationclass Course(models.Model): title = models.CharField(max_length=32) # 不会在数据库中生成字段，只用于数据库操作 # policy = GenericRelation('PricePolicy',object_id_field='object_id',content_type_field='contentType')class DegreeCourse(models.Model): title = models.CharField(max_length=32)class PricePolicy(models.Model): # 跟Django提供的ContentType表做外键关联 contentType = models.ForeignKey(to=ContentType) # 正数 object_id = models.PositiveIntegerField() # 引入一个字段，不会在数据库中创建，只用来做数据库操作 # content_obj = GenericForeignKey('contentType', 'object_id') period = models.CharField(max_length=32) price = models.FloatField() views.py 12345678910111213141516171819202122232425262728293031from app01 import modelsdef test(request): import json # 方式一插入价格规则 # ret=models.ContentType.objects.filter(model='course').first() # course=models.Course.objects.filter(pk=1).first() # print(ret.id) # models.PricePolicy.objects.create(period='30',price=100,object_id=course.id,contentType_id=ret.id) # 方式二插入价格规则 # course=models.Course.objects.filter(pk=1).first() # # content_obj=course 会自动的把课程id放到object_id上，并且去ContentType表中查询课程表的id，放到contentType上 # models.PricePolicy.objects.create(period='60',price=800,content_obj=course) # 增加学位课，价格规则 # degreecourse = models.DegreeCourse.objects.filter(pk=1).first() # models.PricePolicy.objects.create(period='60', price=800, content_obj=degreecourse) # 查询所有价格策略，并且显示对应的课程名称 # ret=models.PricePolicy.objects.all() # for i in ret: # print(i.price) # print(i.period) # # content_obj 就是代指关联的课程，或者学位课程的那个对象 # print(type(i.content_obj)) # print(i.content_obj.title) # 通过课程id，获取课程信息和价格策略 course=models.Course.objects.filter(pk=1).first() print(course.policy.all()) return render(request,'test.html') 七、Rest Framework1.RESTful规范 定义： ①REST是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移” ②所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性 ③REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态 RESTful API设计 ①API与用户的通信协议，总是使用[HTTPs协议 ②域名 ​ https://api.example.com —尽量将API部署在专用域名(会存在跨域问题) ​ https://example.org/api/ —API很简单 ③路径，视网络上任何东西都是资源，均使用名词表示（可复数） https://api.example.com/zoos ④method METHOD Description GET 从服务器取出资源（一项或多项） POST 在服务器新建一个资源 PUT 在服务器更新资源（客户端提供改变后的完整资源） PATCH 在服务器更新资源（客户端提供改变的属性） DELETE 从服务器删除资源 ⑤过滤，通过在url上传参的形式传递搜索条件 https://api.example.com/v1/zoos?limit=10：指定返回记录的数量 https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置 https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数 ⑥状态码 123456789101112200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 ⑦返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 ⑧错误处理，应返回错误信息，error当做key。 123&#123; error: \"Invalid API key\"&#125; ⑨Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 123456&#123;\"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\"&#125;&#125; ⑩版本 URL，如：https://api.example.com/v1/ 2.APIView 安装 123方式一：pip3 install djangorestframework方式二：pycharm图形化界面安装方式三：pycharm命令行下安装（装在当前工程所用的解释器下） Djangorestframework的APIView分析 ① as_view() 123456789101112131415161718192021222324@classmethod def as_view(cls, **initkwargs): \"\"\" Store the original class on the view function. This allows us to discover information about the view when we do URL reverse lookups. Used for breadcrumb generation. \"\"\" if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation view = super(APIView, cls).as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs # Note: session based authentication is explicitly CSRF validated, # all other authentication is CSRF exempt. return csrf_exempt(view) ②dispatch() 12345678910111213141516171819202122232425262728def dispatch(self, request, *args, **kwargs): \"\"\" `.dispatch()` is pretty much the same as Django's regular dispatch, but with extra hooks for startup, finalize, and exception handling. \"\"\" self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response ③initialize_request(重新封装了request对象) 12345678910111213def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) ④initial方法（内部调用认证，权限和频率） 1234567891011121314151617181920def initial(self, request, *args, **kwargs): \"\"\" Runs anything that needs to occur prior to calling the method handler. \"\"\" self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request)initial方法（内部调用认证，权限和频率） 3.序列化组件 Django 自带序列化组件 12345from django.core import serializersdef index(request): book_list = Book.objects.all() ret = serializers.serialize(\"json\", book_list) return HttpResponse(ret) rest-framework序列化之Serializer ① models.py 123456789101112131415161718192021222324from django.db import models# Create your models here.class Book(models.Model): title=models.CharField(max_length=32) price=models.IntegerField() pub_date=models.DateField() publish=models.ForeignKey(\"Publish\") authors=models.ManyToManyField(\"Author\") def __str__(self): return self.titleclass Publish(models.Model): name=models.CharField(max_length=32) email=models.EmailField() def __str__(self): return self.nameclass Author(models.Model): name=models.CharField(max_length=32) age=models.IntegerField() def __str__(self): return self.name ②views.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom app01.models import *from django.shortcuts import HttpResponsefrom django.core import serializersfrom rest_framework import serializersclass BookSerializers(serializers.Serializer): title=serializers.CharField(max_length=32) price=serializers.IntegerField() pub_date=serializers.DateField() publish=serializers.CharField(source=\"publish.name\") #authors=serializers.CharField(source=\"authors.all\") authors=serializers.SerializerMethodField() def get_authors(self,obj): temp=[] for author in obj.authors.all(): temp.append(author.name) return temp #此处可以继续用author的Serializers， # def get_authors(self,obj): # ret=obj.authors.all() # ss=AuthorSerializer(ret,many=True) # return ss.data class BookViewSet(APIView): def get(self,request,*args,**kwargs): book_list=Book.objects.all() # 序列化方式1: # from django.forms.models import model_to_dict # import json # data=[] # for obj in book_list: # data.append(model_to_dict(obj)) # print(data) # return HttpResponse(\"ok\") # 序列化方式2: # data=serializers.serialize(\"json\",book_list) # return HttpResponse(data) # 序列化方式3: bs=BookSerializers(book_list,many=True) #many=True代表有多条数据，如果只有一条数据，many=False return Response(bs.data) # 序列化方式4: # ret=models.Book.objects.all().values('nid','title') # dd=list(ret) # return HttpResponse(json.dumps(dd)) source1234567891011121314151617181920source 如果是字段，会显示字段，如果是方法，会执行方法，不用加括号（authors=serializers.CharField(source='authors.all')）如在模型中定义一个方法，直接可以在在source指定执行class UserInfo(models.Model): user_type_choices = ( (1,'普通用户'), (2,'VIP'), (3,'SVIP'), ) user_type = models.IntegerField(choices=user_type_choices) username = models.CharField(max_length=32,unique=True) password = models.CharField(max_length=64)#视图ret=models.UserInfo.objects.filter(pk=1).first()aa=ret.get_user_type_display()#serializerxx=serializers.CharField(source='get_user_type_display') rest-framework序列化之ModelSerializer 123456789101112131415class BookSerializers(serializers.ModelSerializer): class Meta: model = models.Book # fields = \"__all__\" fields=['nid','title','authors','publish'] # exclude=('nid',) #不能跟fields同时用 # depth = 1 #深度控制，层数越多，响应越慢 publish=serializers.SerializerMethodField() def get_publish(self,obj): return obj.publish.name authors=serializers.SerializerMethodField() def get_authors(self,obj): ret=obj.authors.all() ss=AuthorSerializer(ret,many=True) return ss.data 序列化组件之请求数据校验和保存功能 123456789101112131415class BookSerializers(serializers.ModelSerializer): class Meta: model=Book fields=\"__all__\"class BookView(APIView): def post(self, request): # 添加一条数据 print(request.data) bs=BookSerializers(data=request.data) if bs.is_valid(): bs.save() # 生成记录 return Response(bs.data) else: return Response(bs.errors) 序列化组件源码分析 12345序列化组件，先调用__new__方法，如果many=True，生成ListSerializer对象，如果为False，生成Serializer对象序列化对象.data方法--调用父类data方法---调用对象自己的to_representation（自定义的序列化类无此方法，去父类找）Aerializer类里有to_representation方法，for循环执行attribute = field.get_attribute(instance)再去Field类里去找get_attribute方法，self.source_attrs就是被切分的source，然后执行get_attribute方法，source_attrs当参数传过去，判断是方法就加括号执行，是属性就把值取出来 4.视图组件 基本视图 1234urlpatterns=[ url(r'^publish/$', views.PublishView.as_view()), url(r'^publish/(?P&lt;pk&gt;\\d+)/$', views.PublishDetailView.as_view()),] 1234567891011121314151617181920212223242526272829303132333435363738394041424344class PublishSerializers(serializers.ModelSerializer): class Meta: model=models.Publish fields='__all__'class PublishView(APIView): def get(self, request): publish_list = models.Publish.objects.all() bs = PublishSerializers(publish_list, many=True) # 序列化数据 return Response(bs.data) def post(self, request): # 添加一条数据 print(request.data) bs=PublishSerializers(data=request.data) if bs.is_valid(): bs.save() # 生成记录 return Response(bs.data) else: return Response(bs.errors)class PublishDetailView(APIView): def get(self,request,pk): publish_obj=models.Publish.objects.filter(pk=pk).first() bs=PublishSerializers(publish_obj,many=False) return Response(bs.data) def put(self,request,pk): publish_obj = models.Publish.objects.filter(pk=pk).first() bs=PublishSerializers(data=request.data,instance=publish_obj) if bs.is_valid(): bs.save() # update return Response(bs.data) else: return Response(bs.errors) def delete(self,request,pk): models.Publish.objects.filter(pk=pk).delete() return Response(\"\") mixin类和 generice类编写视图 12345678910111213141516171819202122from rest_framework.mixins import CreateModelMixin,RetrieveModelMixin,ListModelMixin,UpdateModelMixin,DestroyModelMixinfrom rest_framework.generics import GenericAPIViewclass PublishView(ListModelMixin,CreateModelMixin,GenericAPIView): queryset=models.Publish.objects.all() serializer_class=PublishSerializers def get(self, request): return self.list(request) def post(self, request): return self.create(request)class PublishDetailView(RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin,GenericAPIView): queryset=models.Publish.objects.all() serializer_class=PublishSerializers def get(self,request,*args,**kwargs): # retrieve()创建并保存 return self.retrieve(request,*args,**kwargs) def put(self,request,*args,**kwargs): return self.update(request,*args,**kwargs) def delete(self,request,*args,**kwargs): return self.destroy(request,*args,**kwargs) generices 下的ListCreateAPIView，RetieveUpdateDestroyAPIView 12345678from rest_framework.generics import ListCreateAPIView,RetrieveUpdateDestroyAPIViewclass PublishView(ListCreateAPIView): queryset=models.Publish.objects.all() serializer_class=PublishSerializersclass PublishDetailView(RetrieveUpdateDestroyAPIView): queryset=models.Publish.objects.all() serializer_class=PublishSerializers ModelViewSet 12345urlpatterns=[ url(r'^publish/$', views.PublishView.as_view(&#123;'get':'list','post':'create'&#125;)), url(r'^publish/(?P&lt;pk&gt;\\d+)/$', views.PublishView.as_view(&#123;'get':'retrieve','put':'update','delete':'destroy'&#125;)),视图：] 1234from rest_framework.viewsets import ModelViewSetclass PublishView(ModelViewSet): queryset=models.Publish.objects.all() serializer_class=PublishSerializers 5.解析器、认证组件、频率组件、权限组件5.1 解析器 作用 12根据请求头 content-type 选择对应的解析器对请求体内容进行处理。有application/json，x-www-form-urlencoded，form-data等格式 使用解析器 12345678910111213141516171819全局使用在settings.py中配置REST_FRAMEWORK = &#123; # 解析器 'DEFAULT_PARSER_CLASSES':[ 'rest_framework.parsers.JSONParser' 'rest_framework.parsers.FormParser' 'rest_framework.parsers.MultiPartParser' ], # 全局使用认证组件 \"DEFAULT_AUTHENTICATION_CLASSES\":[\"app01.service.auth.Authentication\",], # 全局使用权限组件 \"DEFAULT_AUTHENTICATION_CLASSES\":[\"app01.service.auth.Authentication\",], \"DEFAULT_PERMISSION_CLASSES\":[\"app01.service.permissions.SVIPPermission\",] # 全局使用频率组件,1min访问3次 'DEFAULT_THROTTLE_RATES':&#123; 'luffy':'3/m' &#125;&#125; 12345urls.pyurlpatterns = [ url(r'test/', TestView.as_view()),] 12345678910111213141516171819202122views.pyfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.request import Requestfrom rest_framework.parsers import JSONParser,FormParser,MultiPartParserclass TestView(APIView): # 局部解析器,为MultiPartParser时,前端的form表单中必须有enctype=\"multipart/form-data\" parser_classes = [JSONParser,FormParser,MultiPartParser ] def post(self, request, *args, **kwargs): print(request.content_type) # 获取请求的值，并使用对应的JSONParser进行处理 print(request.data) # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值 print(request.POST) print(request.FILES) return Response('POST请求，响应内容') def put(self, request, *args, **kwargs): return Response('PUT请求，响应内容') 源码分析 123456789101112131415161718192021222324在调用request.data时，才进行解析，由此入手 @property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() return self._full_data查看self._load_data_and_files()方法----&gt;self._data, self._files = self._parse() def _parse(self): #用户请求头里content_type的值 media_type = self.content_type #self.parsers 就是用户配置的parser_classes = [FileUploadParser,FormParser ] #self里就有content_type，传入此函数 parser = self.negotiator.select_parser(self, self.parsers)查看self.negotiator.select_parser(self, self.parsers) def select_parser(self, request, parsers): #同过media_type和request.content_type比较，来返回解析器，然后调用解析器的解析方法 #每个解析器都有media_type = 'multipart/form-data'属性 for parser in parsers: if media_type_matches(parser.media_type, request.content_type): return parser return None最终调用parser的解析方法来解析parsed = parser.parse(stream, media_type, self.parser_context) 123456789101112131415161718192021222324252627282930313233343536373839Request实例化，parsers=self.get_parsers() Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context )get_parsers方法，循环实例化出self.parser_classes中类对象 def get_parsers(self): return [parser() for parser in self.parser_classes] self.parser_classes 先从类本身找，找不到去父类找即APIVIew 中的 parser_classes = api_settings.DEFAULT_PARSER_CLASSESapi_settings是一个对象，对象里找DEFAULT_PARSER_CLASSES属性，找不到，会到getattr方法 def __getattr__(self, attr): if attr not in self.defaults: raise AttributeError(\"Invalid API setting: '%s'\" % attr) try: #调用self.user_settings方法，返回一个字典，字典再取attr属性 val = self.user_settings[attr] except KeyError: # Fall back to defaults val = self.defaults[attr] # Coerce import strings into classes if attr in self.import_strings: val = perform_import(val, attr) # Cache the result self._cached_attrs.add(attr) setattr(self, attr, val) return valuser_settings方法 ，通过反射去setting配置文件里找REST_FRAMEWORK属性，找不到，返回空字典 @property def user_settings(self): if not hasattr(self, '_user_settings'): self._user_settings = getattr(settings, 'REST_FRAMEWORK', &#123;&#125;) return self._user_settings 5.2 认证组件 models.py 12345678class User(models.Model): username=models.CharField(max_length=32) password=models.CharField(max_length=32) user_type=models.IntegerField(choices=((1,'超级用户'),(2,'普通用户'),(3,'二笔用户')))class UserToken(models.Model): user=models.OneToOneField(to='User') token=models.CharField(max_length=64) 新建认证类 1234567891011from rest_framework.authentication import BaseAuthenticationclass TokenAuth(): def authenticate(self, request): token = request.GET.get('token') token_obj = models.UserToken.objects.filter(token=token).first() if token_obj: return else: raise AuthenticationFailed('认证失败') def authenticate_header(self,request): pass views.py 1234567891011121314151617181920212223242526272829303132333435def get_random(name): import hashlib import time md=hashlib.md5() md.update(bytes(str(time.time()),encoding='utf-8')) md.update(bytes(name,encoding='utf-8')) return md.hexdigest()class Login(APIView): def post(self,reuquest): back_msg=&#123;'status':1001,'msg':None&#125; try: name=reuquest.data.get('name') pwd=reuquest.data.get('pwd') user=models.User.objects.filter(username=name,password=pwd).first() if user: token=get_random(name) models.UserToken.objects.update_or_create(user=user,defaults=&#123;'token':token&#125;) back_msg['status']='1000' back_msg['msg']='登录成功' back_msg['token']=token else: back_msg['msg'] = '用户名或密码错误' except Exception as e: back_msg['msg']=str(e) return Response(back_msg)class Course(APIView): # 局部使用 authentication_classes = [TokenAuth, ] def get(self, request): return HttpResponse('get') def post(self, request): return HttpResponse('post') token认证：存数据库的—&gt;Redis—&gt;不存数据库的认证源码分析123456789101112131415161718192021222324252627282930#Request对象的user方法@propertydef user(self):# the authentication classes provided to the request. if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._userdef _authenticate(self): for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise #认证成功，可以返回一个元组，但必须是最后一个验证类才能返回 if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() # self.authenticatorsdef get_authenticators(self): return [auth() for auth in self.authentication_classes]认证类使用顺序：先用视图类中的验证类，再用settings里配置的验证类，最后用默认的验证类 6.2 频率组件 局部使用 1permission_classes = [UserPermission,] 源码分析12345678910def check_permissions(self, request): for permission in self.get_permissions(): if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, 'message', None) ) # self.get_permissions()def get_permissions(self): return [permission() for permission in self.permission_classes] 6.3 权限组件 自定义限制 ip 的访问频率 1234567891011121314151617181920212223242526272829303132333435#（1）取出访问者ip# （2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问，在字典里，继续往下走# （3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，# （4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过# （5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败class MyThrottles(): VISIT_RECORD = &#123;&#125; def __init__(self): self.history=None def allow_request(self,request, view): #（1）取出访问者ip # print(request.META) ip=request.META.get('REMOTE_ADDR') import time ctime=time.time() # （2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问 if ip not in self.VISIT_RECORD: self.VISIT_RECORD[ip]=[ctime,] return True self.history=self.VISIT_RECORD.get(ip) # （3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间， while self.history and ctime-self.history[-1]&gt;60: self.history.pop() # （4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过 # （5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败 if len(self.history)&lt;3: self.history.insert(0,ctime) return True else: return False def wait(self): import time ctime=time.time() return 60-(ctime-self.history[-1]) 局部使用 1throttle_classes = [MyThrottles,] 错误信息的中文提示 1234567891011121314151617class Course(APIView): authentication_classes = [TokenAuth, ] permission_classes = [UserPermission, ] throttle_classes = [MyThrottles,] def get(self, request): return HttpResponse('get') def post(self, request): return HttpResponse('post') def throttled(self, request, wait): from rest_framework.exceptions import Throttled class MyThrottled(Throttled): default_detail = '傻逼啊' extra_detail_singular = '还有 &#123;wait&#125; second.' extra_detail_plural = '出了 &#123;wait&#125; seconds.' raise MyThrottled(wait) 7.分页器 简单分页 1234567891011121314151617181920212223242526272829303132333435from rest_framework.pagination import PageNumberPagination# 一 基本使用：url=url=http://127.0.0.1:8000/pager/?page=2&amp;size=3，size无效class Pager(APIView): def get(self,request,*args,**kwargs): # 获取所有数据 ret=models.Book.objects.all() # 创建分页对象 page=PageNumberPagination() # 在数据库中获取分页的数据 page_list=page.paginate_queryset(ret,request,view=self) # 对分页进行序列化 ser=BookSerializer1(instance=page_list,many=True) return Response(ser.data)# 二 自定制 url=http://127.0.0.1:8000/pager/?page=2&amp;size=3# size=30，无效，最多5条class Mypage(PageNumberPagination): page_size = 2 page_query_param = 'page' # 定制传参 page_size_query_param = 'size' # 最大一页的数据 max_page_size = 5class Pager(APIView): def get(self,request,*args,**kwargs): # 获取所有数据 ret=models.Book.objects.all() # 创建分页对象 page=Mypage() # 在数据库中获取分页的数据 page_list=page.paginate_queryset(ret,request,view=self) # 对分页进行序列化 ser=BookSerializer1(instance=page_list,many=True) # return Response(ser.data) # 这个也是返回Response对象，但是比基本的多了上一页，下一页，和总数据条数（了解即可） return page.get_paginated_response(ser.data) 123456settings.pyREST_FRAMEWORK = &#123; # 每页显示两条 'PAGE_SIZE':2&#125; 123urlpatterns=[ url(r'^pager/$', views.Pager.as_view()),] 偏移分页 12345678910111213141516在第N个位置,向后查看N条数据# http://127.0.0.1:8000/pager/?offset=4&amp;limit=3from rest_framework.pagination import LimitOffsetPagination# 也可以自定制，同简单分页class Pager(APIView): def get(self,request,*args,**kwargs): # 获取所有数据 ret=models.Book.objects.all() # 创建分页对象 page=LimitOffsetPagination() # 在数据库中获取分页的数据 page_list=page.paginate_queryset(ret,request,view=self) # 对分页进行序列化 ser=BookSerializer1(instance=page_list,many=True) # return page.get_paginated_response(ser.data) return Response(ser.data) CursorPagination加密分页 1234567891011121314151617只能查看上页和下页from rest_framework.pagination import CursorPagination# 看源码，是通过sql查询，大于id和小于idclass Pager(APIView): def get(self,request,*args,**kwargs): # 获取所有数据 ret=models.Book.objects.all() # 创建分页对象 page=CursorPagination() page.ordering='nid' # 在数据库中获取分页的数据 page_list=page.paginate_queryset(ret,request,view=self) # 对分页进行序列化 ser=BookSerializer1(instance=page_list,many=True) # 可以避免页码被猜到 return page.get_paginated_response(ser.data) 8.响应器（渲染器） 作用 1根据 用户请求URL 或 用户可接受的类型，筛选出合适的 渲染组件。 内置渲染器 ①默认显示格式：BrowsableAPIRenderer（可以修改它的html文件） http://127.0.0.1:8000/test/?format=api http://127.0.0.1:8000/test.api ②显示json格式：JSONRenderer http://127.0.0.1:8000/test/?format=json http://127.0.0.1:8000/test.json ③表格方式：AdminRenderer http://127.0.0.1:8000/test/?format=admin http://127.0.0.1:8000/test.admin ④form表单方式：HTMLFormRenderer http://127.0.0.1:8000/test/?format=form http://127.0.0.1:8000/test.form 局部使用 1renderer_classes = [HTMLFormRenderer,BrowsableAPIRenderer ] 9.URL控制器 自定义路由（原始方式） 123456from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^books/$', views.BookView.as_view()), url(r'^books/(?P&lt;pk&gt;\\d+)$', views.BookDetailView.as_view()),] 半自动路由（视图继承ModelViewSet） 123456789urls.pyfrom django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^publish/$', views.PublishView.as_view(&#123;'get':'list','post':'create'&#125;)), url(r'^publish/(?P&lt;pk&gt;\\d+)/$', views.PublishView.as_view(&#123;'get':'retrieve','put':'update','delete':'destroy'&#125;)),] 123456views.pyfrom rest_framework.viewsets import ModelViewSetclass PublishView(ModelViewSet): queryset=models.Publish.objects.all() serializer_class=PublishSerializers 全自动路由（自动生成路由） 123456789101112131415161718192021urls.pyfrom django.conf.urls import url,includefrom app01 import viewsfrom rest_framework import routersrouter=routers.DefaultRouter()# 两个参数，一个是匹配的路由，一个是视图中写的CBV的类router.register('publish',views.PublishView)urlpatterns = [ # http://127.0.0.1:8000/publish/format=json(渲染器通过这个判断，返回渲染的页面) # url(r'^publish/', views.PublishView.as_view(&#123;'get':'list','post':'create'&#125;)), # http://127.0.0.1:8000/publish.json(渲染器通过这个判断，返回渲染的页面) # url(r'^publish\\.(?P&lt;format&gt;\\w+)$', views.PublishView.as_view(&#123;'get':'list','post':'create'&#125;)), # 可以用 以下方式访问 # 1 http://127.0.0.1:8000/publish/ # 2 http://127.0.0.1:8000/publish.json # 3 http://127.0.0.1:8000/publish/3 # 4 http://127.0.0.1:8000/publish/3.json url(r'',include(router.urls))] 123456views.pyfrom rest_framework.viewsets import ModelViewSetclass PublishView(ModelViewSet): queryset=models.Publish.objects.all() serializer_class=PublishSerializers 10.版本控制 内置的版本控制类 1234567from rest_framework.versioning import QueryParameterVersioning,AcceptHeaderVersioning,NamespaceVersioning,URLPathVersioning#基于url的get传参方式：QueryParameterVersioning------&gt;如：/users?version=v1#基于url的正则方式：URLPathVersioning------&gt;/v1/users/#基于 accept 请求头方式：AcceptHeaderVersioning------&gt;Accept: application/json; version=1.0#基于主机名方法：HostNameVersioning------&gt;v1.example.com#基于django路由系统的namespace：NamespaceVersioning------&gt;example.com/v1/users/ 局部使用 12#在CBV类中加入versioning_class = URLPathVersioning 全局使用 123456REST_FRAMEWORK = &#123; 'DEFAULT_VERSIONING_CLASS':'rest_framework.versioning.QueryParameterVersioning', 'DEFAULT_VERSION': 'v1', # 默认版本(从request对象里取不到，显示的默认值) 'ALLOWED_VERSIONS': ['v1', 'v2'], # 允许的版本 'VERSION_PARAM': 'version' # URL中获取值的key&#125; 源码分析12345678910#执行determine_version，返回两个值，放到request对象里version, scheme = self.determine_version(request, *args, **kwargs)request.version, request.versioning_scheme = version, schemedef determine_version(self, request, *args, **kwargs): #当配置上版本类之后，就会实例化 if self.versioning_class is None: return (None, None) scheme = self.versioning_class() return (scheme.determine_version(request, *args, **kwargs), scheme) 八、settings.py配置1.APPEND_SLASH12APPEND_SLASH=True是否开启URL访问地址后面不为/跳转至带有/的路径的配置项 2.static（css文件，js文件，图片文件 ）1234STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] html页面对static静态文件的使用 12&lt;link rel=\"stylesheet\" href=\"/static/mycss.css\"&gt; &lt;script src=\"/static/jquery-3.3.1.js\"&gt;&lt;/script&gt; 3 数据库配置12345678910111213141516171819202122232425262728DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'lqz', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': 3306, 'ATOMIC_REQUEST': True, 'OPTIONS': &#123; \"init_command\": \"SET storage_engine=MyISAM\", &#125; &#125;&#125;''''NAME':要连接的数据库，连接前需要创建好'USER':连接数据库的用户名'PASSWORD':连接数据库的密码'HOST':连接主机，默认本机'PORT':端口 默认3306'ATOMIC_REQUEST': True,设置为True统一个http请求对应的所有sql都放在一个事务中执行（要么所有都成功，要么所有都失败）。是全局性的配置， 如果要对某个http请求放水（然后自定义事务），可以用non_atomic_requests修饰器 'OPTIONS': &#123; \"init_command\": \"SET storage_engine=MyISAM\", &#125;设置创建表的存储引擎为MyISAM，INNODB''' 1234567891011# 注意1： 在mysql连接数据库前必须已经创建数据库，而上面的sqlite数据库下的db.sqlite3则是项目自动创建 USER和PASSWORD分别是数据库的用户名和密码。设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。然后，启动项目，会报错：no module named MySQLdb 。这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb 对于py3有很大问题，所以我们需要的驱动是PyMySQL 所以，我们只需要找到项目名文件下的__init__,在里面写入：import pymysqlpymysql.install_as_MySQLdb() 通过两条数据库迁移命令即可在指定的数据库中创建表python manage.py makemigrationspython manage.py migrate# 注意2: 确保配置文件中的INSTALLED_APPS中写入我们创建的app名称 打印orm转换过程中的sql 12345678910111213141516171819202122LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console':&#123; 'level':'DEBUG', 'class':'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', &#125;, &#125;&#125;or# 操作数据库时取出的对象objprint(obj.query) 九、创建Django0 安装Django 1pip install django 1 创建一个 Django project 1django-admin.py startproject mysite 2 在mysite目录下创建应用 1python manage.py startapp app01 3 启动Django项目 1python manage.py runserver http://ip:8000 十、跨域请求（同源策略） 定义 12345同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现同一个 http://ip:port(假设是 http://127.0.0.1:8000)当使用http://127.0.0.1:8001访问时，会抛出错误 已拦截跨源请求：同源策略禁止读取位于 http://127.0.0.1:8001/SendAjax/ 的远程资源。（原因：CORS 头缺少 &apos;Access-Control-Allow-Origin&apos;）。 跨域资源共享（CORS）基本流程 123浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。浏览器发出CORS简单请求，只需要在头信息之中增加一个Origin字段。浏览器发出CORS非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 CORS简单请求 12345678910（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain CORS非简单请求 1凡是不同时满足CORS简单请求条件，就属于非简单请求。 123456789101112两种请求的区别： 简单请求：一次请求 非简单请求：两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。 关于“预检”- 请求方式：OPTIONS- “预检”其实做检查，检查如果通过则允许传输数据，检查不通过则不再发送真正想要发送的消息- 如何“预检” =&gt; 如果复杂请求是PUT等请求，则服务端需要设置允许某请求，否则“预检”不通过 Access-Control-Request-Method =&gt; 如果复杂请求设置了请求头，则服务端需要设置允许某请求头，否则“预检”不通过 Access-Control-Request-Headers Django项目支持CORS ① 在返回的结果中加入允许信息（简单请求） 123456def test(request): import json obj=HttpResponse(json.dumps(&#123;'name':'lqz'&#125;)) # obj['Access-Control-Allow-Origin']='*' obj['Access-Control-Allow-Origin']='http://127.0.0.1:8004' return obj ② 放到中间件处理复杂和简单请求 1234567from django.utils.deprecation import MiddlewareMixinclass CorsMiddleWare(MiddlewareMixin): def process_response(self,request,response): if request.method==\"OPTIONS\": response[\"Access-Control-Allow-Headers\"]=\"Content-Type\" response[\"Access-Control-Allow-Origin\"] = \"http://localhost:8080\" return response 十一、Django中使用Redis方式一①新建utils文件夹，并在该文件夹下建立redis_pool.py 12import redisPOOL = redis.ConnectionPool(host='127.0.0.1', port=6379,password='1234',max_connections=1000) ②视图函数中使用 1234567891011121314import redisfrom django.shortcuts import render,HttpResponsefrom utils.redis_pool import POOLdef index(request): conn = redis.Redis(connection_pool=POOL) conn.hset('kkk','age',18) return HttpResponse('设置成功')def order(request): conn = redis.Redis(connection_pool=POOL) conn.hget('kkk','age') return HttpResponse('获取成功') 方式二①安装django-redis 1pip3 install django-redis ②setting里配置： 123456789101112# redis配置CACHES = &#123; \"default\": &#123; \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379\", \"OPTIONS\": &#123; \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", \"CONNECTION_POOL_KWARGS\": &#123;\"max_connections\": 100&#125; # \"PASSWORD\": \"123\", &#125; &#125;&#125; ③视图函数 123from django_redis import get_redis_connectionconn = get_redis_connection('default')print(conn.hgetall('xxx')) 十二、Django缓存机制1.三个粒度1234567891011121314151617181920211 全站缓存 用中间件： MIDDLEWARE = [ # 'django.middleware.cache.UpdateCacheMiddleware', 'django.middleware.security.SecurityMiddleware', ... # 'django.middleware.cache.FetchFromCacheMiddleware' ] # CACHE_MIDDLEWARE_SECONDS=102 单视图： 用装饰器 from django.views.decorators.cache import cache_page @cache_page(24*60*60) def index(request): pass3 局部页面： &#123;% load cache %&#125; &#123;% cache 5 'test' %&#125; 两个参数：时间，唯一标识 &#123;&#123; ctime &#125;&#125; &#123;% endcache %&#125;","categories":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/categories/Django/"}],"tags":[{"name":"MTV","slug":"MTV","permalink":"http://yoursite.com/tags/MTV/"},{"name":"restframework","slug":"restframework","permalink":"http://yoursite.com/tags/restframework/"}]},{"title":"MySQL基础知识","slug":"MySQL","date":"2018-12-02T16:29:38.991Z","updated":"2018-12-02T16:29:38.995Z","comments":true,"path":"2018/12/03/MySQL/","link":"","permalink":"http://yoursite.com/2018/12/03/MySQL/","excerpt":"MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Linux作为操作系统，Apache 或Nginx作为 Web 服务器，MySQL 作为数据库，PHP/Perl/Python作为服务器端脚本解释器。由于这四个软件都是免费或开放源码软件（FLOSS)，因此使用这种方式不用花一分钱（除开人工成本）就可以建立起一个稳定、免费的网站系统，被业界称为“LAMP“或“LNMP”组合。","text":"MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Linux作为操作系统，Apache 或Nginx作为 Web 服务器，MySQL 作为数据库，PHP/Perl/Python作为服务器端脚本解释器。由于这四个软件都是免费或开放源码软件（FLOSS)，因此使用这种方式不用花一分钱（除开人工成本）就可以建立起一个稳定、免费的网站系统，被业界称为“LAMP“或“LNMP”组合。 一、 Mysql简单认识1.1 数据（Data）的概念123数据是用来描述事物的符号记录,它既可以是数字,也可以是文字、图片、图像、声音等,数据的表现形式多种多样,但它们都可以经过数字化之后存入计算机。&lt;!-- eg --&gt;Luffu,male,18,ONE-PIECE 1.2 数据库（DataBase）的概念1数据库是以某种有组织方式存储的数据集合,即保存有组织的数据的容器(通常是一个文件或者一组文件);可将其想象成一个文件柜,此文件柜是存放数据(不管数据是什么以及如何组织)的物理位置(计算机的存储设备上)。 12&lt;!--注意概念的混淆--&gt;数据库这个属于并不是人们通常使用的数据库软件,数据库软件应称为DBMS(数据库管理系统)。 1.3 表（table）123某种特定类型数据的结构化清单。&lt;!-- 理解 --&gt;存储在表中的数据是一种类型的数据或者一个清单 12&lt;!-- 表名的唯一性 --&gt;表明一般是用来标识自己的,其唯一性取决于多方面,可以是数据库名和表明的结合;虽然在同一个数据库中不能命名两个同样的表明,但是在不同的数据库中却可以使用相同的表明。 1.4 记录1234&lt;!-- 列 --&gt;表中的一个字段,所有的表都是由一个或者多个列组成的,每个列都应该有相应的数据类型(datatype)。&lt;!-- 分解数据 --&gt;可以将多个不同的数据分解成不同的列,这样更易于区分,也有利于对数据的筛选和处理 1234&lt;!-- 行 --&gt;表中的一条记录,经常有人将行(row)称作数据库记录(record),通常来说,这俩术语是可以通用的;但从计数上来说,行才是其正确的术语。&lt;!-- 数据存储 --&gt;表中的数据都是按行存储的,所保存的每个记录存储在自己的行内。 1.5 主键（primary key）123456789一列(或一组列),其值能够唯一的区分表中的每个行;每一行都应该有可以唯一标识自己的一列(或一组列),唯一标识表中每行的这个列(或这组列)称为主键&lt;!-- 主键规则 --&gt;a.任意两行都不具有相同的主键值;b.每个行都必须具有一个主键值(主键列不允许有 NULL 值)。&lt;!-- 选择主键的好习惯 --&gt;a.不更新主键列中的值;b.不重用主键列的值;c.不在逐渐列中使用可能会更改的值 1.6 数据库服务器、数据库管理系统、数据库、表与记录的关系(重点在于理解) 数据库服务器：计算机(对内存要求较高) 数据库管理系统：如MySQL、Oracle、SQLite、Access、MS SQL Server (一个软件) 数据库：product（即文件夹） 表：product_list（文件夹当中的文件） 记录：1 《MySQL必知必会》978-7-115-19112-0 39 （由多个字段组成的信息,即文件中的一行内容） 12345&lt;!-- 总结 --&gt;数据库服务器：运行数据库管理软件数据库管理系统：管理数据库的软件数据库：即文件夹,用来组织文件/表表：即文件,用来存放多行内容/多条记录 2 SQL的概念12&lt;!-- Structured Query Language --&gt;SQL是结构化的查询语言,是一种专门用来与数据库通信的语言。 1234&lt;!-- SQL优点 --&gt;a.不是某个特定供应商专有语言,几乎所有的数据库都适用;b.由描述性很强的英语单词组成,简单易学;c.看上去简单,实际上是一种强有力的语言,灵活使用,可进行非常复杂和高级的数据库操作。 二、 Mysql基础操作1 连接MySQL12345&lt;!--需要信息--&gt;a.主机名（计算机名）,若连接的是本地 MySQL 服务器,为 localhost;b.端口（如果使用默认端口3306之外的端口）;c.合法的用户名d.用户口令（非必须） 2 选择数据库1234&lt;!--use关键字--&gt;use 库名;&lt;!--注意--&gt;一定要加英文状态下的分号,否则进不去,因为在 MySQL 中是用分号来表示结束的 3 常用数据库和表的SQL 语句 SQL语句 解释 showdatabases; 显示数据库名称 show create database 库名; 显示特定数据库的结构以及基本信息 show tables; 获得数据库中的所有表的列表 show create table 表名; 显示特定表的结构以及基本信息 describe 表名(简写成desc 表名); 对每个字段返回一行,行中包括字段名、数据类型、是否允许NULL等信息 show columns from 表名; desc 表名的另一种写法 ———————————————- —————————————————————————————————– show status; 显示广泛的服务器状态信息 show grant; 显示授予用户的安全权限 show error; 显示服务器错误 show warnings; 显示服务器警告 三、 检索数据1 select语句 select语句 解释 select * from 表名; 检索所有的列 select column from 表名; 从表中检索出单个列 select column1,column2 from 表名; 从表中检索出多个列 ——————————————————————– ——————————————————————- select distinct row from 表名; 从表中检索出不同的行 select * from 表名 limit 5; 检索单个列,且只从表开始部分检索出5条数据 select * from 表名 limit 5,5; 表示从表中第五行开始检索出5行的记录 select * from 表名 limit 5 offset 3; 表示从第3行开始去3条记录 select 表名.column from 表名; 从指定的表名中检索出指定的列数据 12345&lt;!--注意--&gt;a.SQL 语句不区分大小写,但是对于 SQL 关键字使用大写,对所有列和表名使用小写,可以是代码易于阅读。b.选择多个列时,注意在列名之间加上逗号,但最后一个列名不加逗号。c.通配符 * 不要随意使用,严重降低检索效率。d.行0检索出来的是第一行而不是行1,所以 limit 1,将检索出第二行而不是第一行,若行数不够则只能返回能得到的行数。 2 排序检索数据1234&lt;!--子句的概念--&gt;SQL语句是由子句构成的,通常由关键字和所提供的数据组成的,有些子句是必须的,有些子句是可选的。&lt;!--排序的子句--&gt;order by:只能位于 from 子句之后,但是在limit之前。 SQL语句 解释 select pro_name from products order by pro_name; 从表products中选取pro_name这一列并按照pro_name排序 select pro_id,pro_name,pro_price from products order by pro_price,pro_name; 从表中选择数据并按照价格姓名排序,若在价格相同的情况下,继续使用姓名排序。 select pro_price from products order by pro_price desc; 从表中检索出数据并按照价格降序进行排序 select pro_price from products order by pro_price asc; 从表中检索出数据并按照价格升序进行排序,一般默认情况就是升序。 12&lt;!--多个列上进行降序排列--&gt;desc只直接作用于其前面的列,若想在多个列上进行降序排序,必须对每个列指定desc关键字。 3 过滤数据123456&lt;!-- where --&gt;只返回指定条件的记录&lt;!-- between ... and ... --&gt;只返回范围内的开始值和结束值(不包括开头和结尾)&lt;!-- 空值 --&gt;NULL:无值,它与字段中包含0,空字符串、或仅仅包含空格不同。 SQL语句 解释 select * from products where id=2; 从表中检索出id=2的记录 select * from poducts where id between 5 and 10; 从表中检索出id在5-10之间的记录 select * from products where email is null; 从表中检索出email是空值的记录 4 数据过滤升级12345678910111213&lt;!-- 操作符 --&gt;用来联结或改变where子句中的子句关键字。&lt;!-- and --&gt;用在where子句中的关键字,用来只是检索满足所有给定条件的行。&lt;!-- or --&gt;用在where子句中的关键字,用来表示检索匹配任一给定条件的行。&lt;!-- in --&gt;where子句中用来指定要匹配值的清单的关键字,功能与or相当。&lt;!-- not --&gt;where子句中用来否定后跟条件的关键字。&lt;!-- and和or的优先级 --&gt;在and和or同时使用时,and的优先级高于or,若想检索出的结果不被打乱,可以加上括号。 SQL语句 解释 select * from products where id=2 and price=123; 检索出同时是id=2和price=123的记录 select * from products where id=2 or price=123; 检索出id=2或者price=123的记录 select pro_name from products where id in (1,2,3,4,5); 检索出id在1-5范围内的pro_name select pro_name from products where id not in (1,2,3,4,5); 检索出id不在1-5范围内的pro_name 5 用通配符进行过滤123456&lt;!--通配符--&gt;用来匹配值的一部分的特殊字符&lt;!--搜索模式--&gt;由字面值、通配符或者两者组合构成的搜索条件&lt;!--注意--&gt;通配符的位置会影响到结果,使用时应注意通配符的位置 通配符 解释 like 严格意义上like是谓词,而不是操作符 % 可以匹配多个任意字符,根据位置不同而不同 _ 可以匹配单个任意字符 6 正则12&lt;!-- 写法 --&gt;select sth from table where sth REGEXP '正则表达式' order by sth; 12345678910&lt;!-- LIKE与REGEXP的区别 --&gt;LIKE匹配整个列,若匹配的文本在列中,LIKE不会找到它,所以就不会有结果返回;REGEXP在列之内进行匹配,若被匹配的文本在列值中出现,REGEXP将会找到并返回这个文本。&lt;!-- '1|2 3'和'[12] 3'的区别 --&gt;'1|2 3' 表示的是匹配 '1' 或者 '2 3';'[12] 3' 表示的是匹配 '1 3' 或者 '2 3'&lt;!-- MySQL中的转义符与其他正则表达式中的转义符 --&gt;MySQL中需要使用两个 \\\\ 来表示转义符,如 \\\\- 表示 - , \\\\. 表示 . ;其他正则表示是用 \\ 来表示转义符。 四、 字段1 字段1234567891011121314&lt;!-- 字段 --&gt;与列的意思基本上相同,不过数据库列一般称为列,而术语字段通常用在计算字段连接上。&lt;!-- 拼接 --&gt;将值联结到一起构成单个值。&lt;!-- MySQL的不同之处 --&gt;多数的DBMS使用 + 或 || 实现字符串拼接,而MySQL是使用Concat()函数来实现。当将SQL语句转成MySQL时需要注意。&lt;!-- Trim()函数 --&gt;去掉两边的空格&lt;!-- 使用别名 --&gt;在实际的表列明包含不符合规定的字符时重新命名它。 五、 聚合函数1 聚合函数12345&lt;!-- 聚合函数 --&gt;运行在行组上,计算和返回单个值的函数。&lt;!-- 列值为NULL的行 --&gt;函数将忽略列值为NULL的行 函数 说明 avg() 返回某列的平均值,若需要多个列的平均值,需要多个avg()函数 count() 返回某列的行数 max() 返回某列的最大值 min() 返回某列的最小值 sum() 返回某列值之和 123&lt;!-- 聚集不同的值 DISTINCT --&gt;a.指定列名,则distinct只能用于count()。distinct不能用于count(*) ,因此不允许使用count(distinct),否则产生错误。b.将distinct用于max()和min()从技术上可用,但是没有实际价值。 12&lt;!-- 组合聚合函数 --&gt;可以同时使用多个聚合函数。 六、 数据分组1 创建分组1234&lt;!-- group by的规定 --&gt;a.group by子句可以包含任意数目的列,可以对分组进行嵌套,为数据分组提供更细致的控制。b.若在group by子句中潜逃了分组,数据将在最后规定的分组上进行汇总。c.group by子句中的每个列都必须是检索列或者有效的表达式(不能是聚合函数)。 2 过滤分组123&lt;!-- having与where的区别 --&gt;where:在数据分组前进行过滤,过滤的是行;having:在数据分组之后进行过滤,过滤的是分组。 3 分组和排序 order by group by 排序产生的输出 分组行,输出的可能不是分组的顺序 任意列都可使用 只可使用选择列或表达式列,而且必须使用每个选择列表达式。 不一定需要 若与聚合函数配合使用,则必须使用 七、 关键词执行顺序汇总 子句 说明 是否必要 select 返回的列或者表达式 √ distinct 去除重复的值 × from 从中检索数据的表 仅在从表中选择数据是使用 where 行级过滤 × group by 分组的说明 仅在按组计算聚合时使用 having 组级过滤 × order by 输出的顺序排序 × limit 需要检索出的具体行数 × 八、 子查询和组合查询1 子查询123456789101112&lt;!-- 子查询 --&gt;将一条select语句的执行结果用于另一条select语句的whereas子句&lt;!-- 注意 --&gt;使用子查询时,列必须匹配。在where子句中使用子查询,应保证select语句具有与where子句中相同数目的列。&lt;!-- 相关子查询 --&gt;涉及外部查询的子查询;如 where table1.id = table2.new_id;&lt;!-- 操作符 --&gt;in = !=select c_name where c_id in (select c_id from table1 where c_id != 0) from table2 roder by c_name; 2 组合查询12345678910111213141516171819202122232425&lt;!-- 组合查询的使用 --&gt;a.在单个查询中从不同的表返回类似结构的数据;b.对单个表执行多个查询,按单个查询返回数据。&lt;!-- union规则 --&gt;a.union必须由两条或者两条以上的select语句组成,语句间用关键字union分隔。b.union中的每个查询必须包含相同列、表达式或聚合函数。c.类数据类型必须兼容：类型不必完全相同,但必须是DBMS可以隐含地转换的类型。&lt;!-- 使用union --&gt;给出每条select语句,在语句之间放上关键字unionselect c_name from table1 where c_id&gt;0;select p_name from table2 where p_id between 5 and 10;select c_name from table1 where c_id&gt;0unionselect p_name from table2 where p_id between 5 and 10;&lt;!-- 包含或取消重复的行 --&gt;可以使用union all来显示出所有的行&lt;!-- 对组合查询结果排序 --&gt;使用union查询时,只能使用一条order by子句,且必须出现在最后一条select语句之后。 九、 联结表和创建高级联结1 联结12345&lt;!-- 外键 --&gt;外键为某个表中的一列,包含另外一个表的主键值,定义了两个表之间的关系。&lt;!-- 可伸缩性 --&gt;能够适应不断增加的工作量而不失败,设计良好的数据库或应用程序称之为可伸缩性好。 12345&lt;!-- 创建联结 --&gt;select c_name,c_addr,p_name from customer,product where customer.c_id = products.p_id;&lt;!-- 内部联结 --&gt;select c_name,p_name,p_price from customer inner join products on customer.c_id = products.p_id; 2 高级联结1234567891011121314&lt;!-- 自联结 --&gt;自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。子查询解决方案:select p_name from products where c_id in (select c_id from customer where p_id=10);联结查询:select p.p_name from customer as c,products as p where p.p_id = c.c_id and c.c_id=10;&lt;!-- 自然联结 --&gt;无论何时对表进行联结,应至少有一个列出现在不知一个表中(被联结的列)。&lt;!-- 外部联结 --&gt;将一个表中的行与另外一个表中的行相关联,包含没有关联行的那些行。语法与内部联结相似,left outer join 或者 right outer join&lt;!-- 带有聚合函数的联结 --&gt;select c.c_name,c.c_id count(o.order_num) as num_ord from customer as c inner join orders as o on c.c_id = o.c_id; 十、 数据操作1 插入数据1234&lt;!-- 插入数据 --&gt;a.insert into tablename values (value1,value2,...)b.insert into tablename(字段1,字段2,...) values (value1,value2,...)a 的语法虽然简单但是不安全,应尽量避免使用。b 的语法复杂但是更安全,且不用根据表结构来插入数据了。 2 更新数据12345678&lt;!-- 更新数据 --&gt;update tablename set 字段名1 = value1, [字段名2 = value2, ... ] where 字段名 = value;&lt;!-- 注意 --&gt;使用update时应该配合使用where语句,若没有where语句,MySQL将会更细心表中的所有数据。 3 删除数据123456789&lt;!-- 删除数据 --&gt;delete from tablename where 字段名 = value;&lt;!-- 注意 --&gt;delete删除的是行使用delete时应该配合使用where语句,若没有where语句,MySQL将会更细心表中的所有数据。&lt;!-- 快速的删除所有行 --&gt;使用truncate table,实际上是删除原来的表并重新创建一个表,而不是逐行的删除数据。 十一、 表操作1 创建表123456&lt;!-- 创建表 --&gt;create table tablename[if not exists]( id int primary_key auto_increment, name varchar(32) not null, password varchar(64) nul null default=\"123\", ) ENGINE = InnoDB; 1234567&lt;!-- 需要知道的引擎 --&gt;InnoDB:可靠地事物处理引擎,不支持全文本搜索;MEMORY:功能等同于MyISAM,由于数据存储在内存中,速度很快,但是断电就丢失(适合用于临时表);MyISAM:性能极高,支持全文本搜索,但不支持事物处理。&lt;!-- 注意 --&gt;外键不能跨引擎,混用引擎有缺陷,外键不能跨引擎,即一个使用引擎的表不能引用具有不同引擎的表的外键。 2 更新表1234567891011&lt;!-- 添加列 --&gt;alter table tablename add 字段1 类型 [,字段2 类型] ...&lt;!-- 删除列 --&gt;alter table tablename drop column 字段;&lt;!-- alter table常见用途 --&gt;用来定义外键,alter table talbename add constraint fk_tablename1_tablename2 foreign key (tablename2的字段id) refernces tablename2的字段 (tablename2的字段id)alter table orderitems add constraint fk_orderitems_orders foreign key (order_num) references orders(order_num); 3 删除表12&lt;!-- 删除表 --&gt;drop table tablename; 4 重命名表12&lt;!-- 重命名表 --&gt;rename table oldtablename to newtablename; 十二、 视图1 视图1234567891011121314151617181920212223242526272829&lt;!-- 视图 --&gt;视图是一个虚拟的表,与包含数据的表是不一样的,视图只包含使用时动态检索数据的查询。所以,对视图进行增加或者删除操作,实际上是对其基表进行增加或者删除。但是视图一般都是用来检索,而不是用来更新。&lt;!-- 视图的常见应用 --&gt;a.重用SQL语句b.简化复杂的SQL操作。即编写查询之后,可以更方便的重用它而了解它的基本查询细节c.使用的是表的组成部分而不是整个表d.保护数据,可以给用户授予表的特定部分的访问权限而不是整个表的访问权限e.更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。&lt;!--视图的使用--&gt;创建视图：create view viewname as select ... ;查看视图：show create view viewname;更新视图：create or replace view; 或者先 drop 再 create删除视图：drop view viewname;&lt;!-- 更新视图的注意点 --&gt;并非所有的视图都是可以更新的。若MySQL不能准确地确定被更新的 基数据,则不允许更新。则视图定义中有一下操作时,不能进行视图更新：a.分组(group by 和 having)b.联结c.子查询d.并e.聚合函数f.distinctg.导出列上述的限制只限于MySQL5以前,之后可能会更改。 十三、 游标1 游标12345678&lt;!-- 使用游标注意事项 --&gt;游标只能用于存储过程。不像多数DBMS,MySQL游标只能使用于存储过程和函数。&lt;!-- 使用游标的步骤 --&gt;a.先声明(定义)游标,这个过程并没有检索数据,只是定义了使用的SELECT语句。b.打开游标以供使用。这个过程将定义的SELECT语句将数据检索出来。c.对于填有数据的游标,根据需要检索各行。d.结束游标使用时,关闭游标。 2 使用游标2.1 创建游标123456789CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR &lt;!--declare命名游标--&gt; FOR SELECT order_num FROM orders;END;&lt;!-- 注意 --&gt;存储过程处理完成之后,游标就会消失。 2.2 打开和关闭游标1234&lt;!-- 打开 --&gt;OPEN ordernumbers;&lt;!-- 关闭 --&gt;CLOSE ordernumbers; &lt;!--关闭所有内部内存和资源--&gt; 2.3 使用游标数据12345678910111213141516171819202122232425262728293031CREATE PROCEDURE processorder()BEGIN &lt;!--Declare local variable--&gt; DECLARE ordernumers CURSOR DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); &lt;!--Declare the cursor--&gt; DECLARE ordernumbers CURSOR FOR SELECT order_num FORM orders; &lt;!--Declare continue handler--&gt; DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1; &lt;!--循环的结束条件--&gt; &lt;!--Create a table to store the results--&gt; CREATE TABLE IF NOT EXISTS ordertotals (order_num INT, total DECIMAL(8,2)); &lt;!--Open the cursor--&gt; OPEN ordernumbers; &lt;!--Loop through all rows--&gt; REPEAT &lt;!--Get order number--&gt; FETCH ordernumvers INTO O; &lt;!--使用fetch检索order_num直至done为真--&gt; &lt;!--Get the total for this order--&gt; CALL ordertotal(o, 1, t); &lt;!--Insert order and total into ordertotals--&gt; INSERT INTO ordertotals(order_num, total) VALUES(o, t); &lt;!--End of loop--&gt; UNTIL done END REPEAT; &lt;!--Close the cursor--&gt; CLOSE ordernumbers;END; 十五、 触发器1 触发器1234567&lt;!-- 触发器 --&gt;在某个表发生变化时另一个表更改时自动处理&lt;!-- 支持语句 --&gt;DELETEINSERTUPDATE其他语句不支持触发器 2 创建触发器12345678&lt;!-- 指定条件 --&gt;a.唯一的触发器名b.触发器关联的表c.触发器应该相应的活动d.触发器何时执行&lt;!-- 语法 --&gt;CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added';&lt;!-- 触发器支持的只有表,视图不支持 --&gt; 3 删除触发器12&lt;!-- 删除触发器 --&gt;DROP TRIGGER newproduct; 4 INSERT 触发器1CREATE TRIGGER neworder AFTER INSERT ON orders FOR EACH ROW SELECT NEW.order_num; 5 DELETE 触发器12345CREATE TRIGGER deleteorder BEFORE DELETE ON orders FOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.CUST_ID);END; 6 UPDATE 触发器12CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET.vend_state = Upper(NEW.vend_state); 十六、 事物处理1 事物处理12345678&lt;!-- 事物处理 --&gt;可以用于维护数据库的完整性,即保证同一批次的MySQL操作要么全部操作成功,要么全部操作失败。&lt;!-- 事物处理的几个术语 --&gt;事物(transaction):指的是一组SQL语句;回退(rollback):指的是撤销指定SQL语句的过程;提交(commit):将未存储的SQL语句结果写入数据库表;保留点(savepoint):指事物处理中设置的临时占位符(place-holder),可以对这一操作进行回退。 2 控制事物处理12&lt;!-- 标识事物开始 --&gt;START TRANSACTION 12345678910111213141516&lt;!-- 使用ROLLBACK --&gt;SELECT * FROM ordertotals; &lt;!--显示记录--&gt;START TRANSACTION; &lt;!--开始事物--&gt;DELETE FROM ordertotals; &lt;!--删除记录--&gt;SELECT * FROM ordertotals; &lt;!--显示空的记录表--&gt;ROLLBACK; &lt;!--事物回退--&gt;SELECT * FROM ordertotals; &lt;!--重新显示记录--&gt;&lt;!-- 可以回退的SQL语句 --&gt;INSERTUPDATEDELETE&lt;!-- 不能回退的SQL语句 --&gt;SELECTCREATEDROP 1234567891011MySQL中的SQL语句都是针对数据库表执行和表写的,一般都是隐含提交(implicit commit)。即提交操作自动进行。但是在事物处理中,提交并不会自动执行,所以就需要用到 COMMIT 语句。&lt;!-- 使用COMMIT --&gt;START TRANSACTION;DELETE FROM orderitems WHERE order_num = 10000; &lt;!--删除记录--&gt;DELETE FROM orders WHERE order_num=10000; &lt;!--若上一条记录删除失败,则不会执行COMMIT操作--&gt;COMMIT;&lt;!-- 更改默认的提交行为 --&gt;SET autocommit=0;autocommit针对的是每个连接而不是服务器。 12345678&lt;!-- 使用保留点 --&gt;可以支持回到部分事物处理SAVEPOINT delete1; &lt;!--保留点应取唯一名字--&gt;ROLLBACK TO delete1;&lt;!-- 释放保留点 --&gt;MySQL5之后支持释放保留点RELEASE SAVEPOINT 十七、 存储过程1 使用存储过程的原因1234567891011&lt;!-- 原因 --&gt;优点：a.将接口封装在易于使用的单元中,简化复杂的操作。b.不要求反复建立一系列处理步骤,保证了数据的安全性。因为程序执行的步骤越多,出错的概率也就越大。c.简化对变动的管理。即安全性。d.提高性能。使用存储过程比使用单独的SQL语句要快。e.存在只能用在单个请求中的MySQL元素和特性,存储过程即可以使用他们来编写功能更强更灵活的代码。总结上述：即简单、安全、高性能。缺点：a.编写比SQL语句复杂。b.没有创建存储过程的安全访问权限。 2 存储过程的使用2.1 创建存储过程1234567891011121314&lt;!-- 临时更改MySQL命令行客户机的分隔符 --&gt;DELEMITER // &lt;!--告诉程序使用 // 作为临时结束分隔符--&gt;CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM productsEND // &lt;!--标志存储过程结束--&gt;DELIMITER ; &lt;!--恢复原来的分隔符--&gt;&lt;!-- 注意 --&gt;\\ 符号不能作为语句分隔符,其余均可。&lt;!-- 使用存储过程 --&gt;CALL productpricing() 2.2 删除存储过程1234DROP PROCEDURE productpricing;&lt;!-- 注意 --&gt;a.后边没有使用 ()b.过程不存在,则会报错;可使用DROP PROCEDURE IF EXISTS productpricing 2.3 配合参数使用123456789101112131415161718&lt;!-- 创建 --&gt;CREATE PROCEDURE productpricing( OUT pl DECIMAL(8,2), &lt;!--out关键字指出相应参数用来从存储过程传出值给调用者,IN表示传递给存储过程--&gt; OUT ph DECIMAL(8,2), &lt;!--INOUT表示对存储过程传入和传出--&gt; OUT pa DECIMAL(8,2), &lt;!--DECIMAL为数据类型--&gt;)BEGIN SELECT Min(prod_price) INTO pl from products; &lt;!--存储过程代码位于begin与end之间--&gt; SELECT Max(prod_price) INTO ph from products; &lt;!--通过INTO关键字保存至相应的变量--&gt; SELECT Avg(prod_price) INTO pa from products;END;&lt;!-- 使用 --&gt;CALL productpricing(@pricelow, @pricehigh, @priceaverage);这条语句并不会显示任何数据。仅仅是返回以后可以显示的变量;若想要显示数据,可以使用一下语句：SELECT @pricehigh, @pricelow, @priceaverage; 2.4 检查存储过程123SHOW CREATE PROCEDURE ordertotal; &lt;!--显示传建一个存储过程的create语句--&gt;SHOW PROCEDURE STATUS; &lt;!--显示何时、有谁创建等详细信息的存储过程--&gt;SHOW PROCEDURE STATUS LIKE 'ORDERTOTAL'; &lt;!--过滤模式--&gt;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]}]}