<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>网络编程Socket | VIP</title>
  
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="https://xaoxuu.com/assets/img/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="VIP">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <link rel="shortcut icon" href="https://xaoxuu.com/assets/img/favicon.ico">
  <link rel="icon" href="https://xaoxuu.com/assets/img/favicon.ico">
  
  <link href="https://fonts.googleapis.com/css?family=Ubuntu|Ubuntu+Mono" rel="stylesheet">
  
  <!-- <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?xxx";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>
</html>
<body>
    <div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href="/">VIP</a>
				<div class="menu">
					<ul class="h-list">
            
    					
    						<li>
    							<a class="nav flat-box" href="https://www.ice5.vip/">
    								<i class="fas fa-home fa-fw"></i>&nbsp;主页
  								</a>
  							</li>
        			
    						<li>
    							<a class="nav flat-box" href="https://www.ice5.vip/">
    								<i class="fas fa-project-diagram fa-fw"></i>&nbsp;项目
  								</a>
  							</li>
        			
    						<li>
    							<a class="nav flat-box" href="/">
    								<i class="fas fa-paper-plane fa-fw"></i>&nbsp;博客
  								</a>
  							</li>
        			
    						<li>
    							<a class="nav flat-box" href="/archives/">
    								<i class="fas fa-folder fa-fw"></i>&nbsp;归档
  								</a>
  							</li>
        			
    						<li>
    							<a class="nav flat-box" href="https://www.ice5.vip/">
    								<i class="fas fa-users fa-fw"></i>&nbsp;关于
  								</a>
  							</li>
        			
        		
					</ul>
					<div class="underline"></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-top"><a class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
		<nav>
      <ul>
          
              
                  <li>
										<a class="nav  flat-box" href="https://www.ice5.vip/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a class="nav  flat-box" href="https://www.ice5.vip/">
											<i class="fas fa-project-diagram fa-fw"></i>&nbsp;项目
										</a>
                  </li>
              
                  <li>
										<a class="nav  flat-box" href="/">
											<i class="fas fa-paper-plane fa-fw"></i>&nbsp;博客
										</a>
                  </li>
              
                  <li>
										<a class="nav  flat-box" href="/archives/">
											<i class="fas fa-folder fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a class="nav  flat-box" href="https://www.ice5.vip/">
											<i class="fas fa-users fa-fw"></i>&nbsp;关于
										</a>
                  </li>
              
       
      </ul>
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            <article id="post-网络编程之Socket" class="post white-box article-type-post" itemscope="" itemprop="blogPost">
    <section class="meta">
        
            <h1 class="title">网络编程Socket</h1>
        
        <time class="time">
            <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
            2018-12-05
        </time>
        
          <div class="browse busuanzi"><i class="fas fa-eye fa-fw" aria-hidden="true"></i>
            <span id="busuanzi_value_page_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
          </div>
        

        
    
    <div class="cats">
        <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
        <a class="categories" href="/categories/网络编程/">网络编程</a>
    </div>


    </section>

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1544038313921&amp;di=8d6e8d5ee6206554600f9abe609f2593&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1895326200%2C873420298%26fm%3D214%26gp%3D0.jpg" alt="Socket通信模型"></p>
<a id="more"></a>
<h1 id="一、Socket层的位置"><a href="#一、Socket层的位置" class="headerlink" title="一、Socket层的位置"></a>一、Socket层的位置</h1><p>在<a href="https://www.ice5.vip/2018/12/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">网络编程基础</a>中，我们已经了解到Socket层的位置，这边我们来再次回顾一下，加深印象。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1544038309996&amp;di=fefa31ad36cb8fa9d8d5aae4a92de30b&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D3233222235%2C290543934%26fm%3D214%26gp%3D0.jpg" alt="Socket位置"></p>
<h1 id="二、Socket的概念"><a href="#二、Socket的概念" class="headerlink" title="二、Socket的概念"></a>二、Socket的概念</h1><blockquote>
<p>Socket是应用层与TCP/IP协议族通信的<strong>中间软件抽象层</strong>，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 </p>
</blockquote>
<p>所以，这边我们就暂时无需深入理解<code>tcp/udp</code>协议，<code>socket</code>已经为我们封装好了，我们只需要遵循<code>socket</code>的规定去编程，写出的程序自然就是遵循<code>tcp/udp</code>标准的。 </p>
<ul>
<li><strong>注意：</strong></li>
</ul>
<blockquote>
<p>可能会有人将socket说成<code>ip+port</code>，<code>ip</code>是用来标识互联网中的一台主机的位置，而<code>port</code>是用来标识这台机器上的一个应用程序，<code>ip</code>地址是配置到网卡上的，而<code>port</code>是应用程序开启的，<code>ip</code>与<code>port</code>的绑定就标识了互联网中独一无二的一个应用程序，而程序的<code>pid</code>是同一台机器上不同进程或者线程的标识。</p>
</blockquote>
<h1 id="三、套接字家族发展史以及分类"><a href="#三、套接字家族发展史以及分类" class="headerlink" title="三、套接字家族发展史以及分类"></a>三、套接字家族发展史以及分类</h1><blockquote>
<p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 </p>
</blockquote>
<h2 id="1-基于文件类型的套接字家族"><a href="#1-基于文件类型的套接字家族" class="headerlink" title="1.基于文件类型的套接字家族"></a>1.基于文件类型的套接字家族</h2><blockquote>
<p>  套接字家族的名字：AF_UNIX </p>
</blockquote>
<p>Unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信 。</p>
<h2 id="2-基于网络类型的套接字家族"><a href="#2-基于网络类型的套接字家族" class="headerlink" title="2.基于网络类型的套接字家族"></a>2.基于网络类型的套接字家族</h2><blockquote>
<p>套接字家族的名字：AF_INET </p>
</blockquote>
<p>还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。</p>
<h1 id="四、套接字工作流程"><a href="#四、套接字工作流程" class="headerlink" title="四、套接字工作流程"></a>四、套接字工作流程</h1><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1544038374616&amp;di=5691486fc2a8126cabc629b589898d72&amp;imgtype=0&amp;src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F5183118-609b90e5f0475927.jpg" alt="套接字工作流程"></p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h2 id="1-socket-模块函数用法"><a href="#1-socket-模块函数用法" class="headerlink" title="1.socket()模块函数用法"></a>1.socket()模块函数用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(socket_family,socket_type,protocal=<span class="number">0</span>)</span><br><span class="line">socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">获取tcp/ip套接字</span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">获取udp/ip套接字</span><br><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">由于 socket 模块中有太多的属性。我们在这里破例使用了<span class="string">'from module import *'</span>语句。使用 <span class="string">'from socket import *'</span>,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。</span><br><span class="line">例如tcpSock = socket(AF_INET, SOCK_STREAM)</span><br></pre></td></tr></table></figure>
<h2 id="2-服务端套接字函数"><a href="#2-服务端套接字函数" class="headerlink" title="2.服务端套接字函数"></a>2.服务端套接字函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.bind()</td>
<td>绑定(主机,端口号)到套接字</td>
</tr>
<tr>
<td>s.listen()</td>
<td>开始TCP监听</td>
</tr>
<tr>
<td>s.accept()</td>
<td>被动接受TCP客户的连接,(阻塞式)等待连接的到来</td>
</tr>
</tbody>
</table>
<h2 id="3-客户端套接字函数"><a href="#3-客户端套接字函数" class="headerlink" title="3.客户端套接字函数"></a>3.客户端套接字函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.connect()</td>
<td>主动初始化TCP服务器连接</td>
</tr>
<tr>
<td>s.connect_ex()</td>
<td>connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td>
</tr>
</tbody>
</table>
<h2 id="4-公共用途的套接字函数"><a href="#4-公共用途的套接字函数" class="headerlink" title="4.公共用途的套接字函数"></a>4.公共用途的套接字函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.recv()</td>
<td>接收TCP数据</td>
</tr>
<tr>
<td>s.send()</td>
<td>发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)</td>
</tr>
<tr>
<td>s.sendall()</td>
<td>发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)</td>
</tr>
<tr>
<td>s.recvfrom()</td>
<td>接收UDP数据</td>
</tr>
<tr>
<td>s.sendto()</td>
<td>发送UDP数据</td>
</tr>
<tr>
<td>s.getpeername()</td>
<td>连接到当前套接字的远端的地址</td>
</tr>
<tr>
<td>s.getsockname()</td>
<td>当前套接字的地址</td>
</tr>
<tr>
<td>s.getsockopt()</td>
<td>返回指定套接字的参数</td>
</tr>
<tr>
<td>s.setsockopt()</td>
<td>设置指定套接字的参数</td>
</tr>
<tr>
<td>s.close()</td>
<td>关闭套接字</td>
</tr>
</tbody>
</table>
<h2 id="5-面向锁的套接字方法"><a href="#5-面向锁的套接字方法" class="headerlink" title="5.面向锁的套接字方法"></a>5.面向锁的套接字方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.setblocking()</td>
<td>设置套接字的阻塞与非阻塞模式</td>
</tr>
<tr>
<td>s.settimeout()</td>
<td>设置阻塞套接字操作的超时时间</td>
</tr>
<tr>
<td>s.gettimeout()</td>
<td>得到阻塞套接字操作的超时时间</td>
</tr>
</tbody>
</table>
<h2 id="6-面向文件的套接字的函数"><a href="#6-面向文件的套接字的函数" class="headerlink" title="6.面向文件的套接字的函数"></a>6.面向文件的套接字的函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.fileno()</td>
<td>套接字的文件描述符</td>
</tr>
<tr>
<td>s.makefile()</td>
<td>创建一个与该套接字相关的文件</td>
</tr>
</tbody>
</table>
<h1 id="五、基于TCP的套接字"><a href="#五、基于TCP的套接字" class="headerlink" title="五、基于TCP的套接字"></a>五、基于TCP的套接字</h1><blockquote>
<p>  TCP是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</p>
</blockquote>
<h2 id="1-TCP服务端"><a href="#1-TCP服务端" class="headerlink" title="1.TCP服务端"></a>1.TCP服务端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ss = socket() <span class="comment">#创建服务器套接字</span></span><br><span class="line">ss.bind()      <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">ss.listen()      <span class="comment">#监听链接</span></span><br><span class="line">inf_loop:      <span class="comment">#服务器无限循环</span></span><br><span class="line">    cs = ss.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">    comm_loop:         <span class="comment">#通讯循环</span></span><br><span class="line">        cs.recv()/cs.send() <span class="comment">#对话(接收与发送)</span></span><br><span class="line">    cs.close()    <span class="comment">#关闭客户端套接字</span></span><br><span class="line">ss.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-TCP客户端"><a href="#2-TCP客户端" class="headerlink" title="2.TCP客户端"></a>2.TCP客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">cs = socket()    <span class="comment"># 创建客户套接字</span></span><br><span class="line">cs.connect()    <span class="comment"># 尝试连接服务器</span></span><br><span class="line">comm_loop:        <span class="comment"># 通讯循环</span></span><br><span class="line">     cs.send()/cs.recv()    <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()            <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>
<h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h2><blockquote>
<p>  socket通信流程与打电话流程类似，我们就以打电话为例来实现套接字通信</p>
</blockquote>
<ul>
<li><strong>服务端</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>)          <span class="comment"># 电话卡</span></span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="comment"># 买手机</span></span><br><span class="line">s.bind(ip_port)                     <span class="comment"># 手机插卡</span></span><br><span class="line">s.listen(<span class="number">5</span>)                         <span class="comment"># 手机待机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:                         <span class="comment"># 新增接收链接循环,可以不停的接电话</span></span><br><span class="line">    conn,addr=s.accept()            <span class="comment"># 手机接电话</span></span><br><span class="line">    <span class="comment"># print(conn)</span></span><br><span class="line">    <span class="comment"># print(addr)</span></span><br><span class="line">    print(<span class="string">'接到来自%s的电话'</span> %addr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:                     <span class="comment"># 新增通信循环,可以不断的通信,收发消息</span></span><br><span class="line">        msg=conn.recv(BUFSIZE)      <span class="comment"># 听消息,听话</span></span><br><span class="line">        <span class="comment"># if len(msg) == 0:break    # 如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生</span></span><br><span class="line">        print(msg,type(msg))</span><br><span class="line">        conn.send(msg.upper())      <span class="comment"># 发消息,说话</span></span><br><span class="line">    conn.close()                    <span class="comment"># 挂电话</span></span><br><span class="line">s.close()                           <span class="comment"># 手机关机</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect_ex(ip_port)                  <span class="comment"># 拨电话</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:                            <span class="comment"># 新增通信循环,客户端可以不断发收消息</span></span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))         <span class="comment"># 发消息,说话(只能发送字节类型)</span></span><br><span class="line">    feedback=s.recv(BUFSIZE)            <span class="comment"># 收消息,听话</span></span><br><span class="line">    print(feedback.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.close()                               <span class="comment"># 挂电话</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在重启服务端时可能会遇到<code>OSError</code>的问题</p>
<blockquote>
<p>  出现改原因是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法） </p>
</blockquote>
</li>
</ul>
<p><strong>解决方法</strong></p>
<ol>
<li><p>加入一条socket配置，重用ip和端口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phone=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>) <span class="comment"># 就是它，在bind前加</span></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现系统存在大量TIME_WAIT状态的连接，通过调整Linux内核参数解决</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑文件，加入以下内容</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行 /sbin/sysctl -p 让参数生效</span></span><br><span class="line"> </span><br><span class="line">net.ipv4.tcp_syncookies = 1 # 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1   # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 # 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</span><br><span class="line">net.ipv4.tcp_fin_timeout    # 修改系統默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="六、基于UDP的套接字"><a href="#六、基于UDP的套接字" class="headerlink" title="六、基于UDP的套接字"></a>六、基于UDP的套接字</h1><blockquote>
<p>  UDP是无链接的，先启动哪一端都不会报错</p>
</blockquote>
<h2 id="1-UDP服务端"><a href="#1-UDP服务端" class="headerlink" title="1.UDP服务端"></a>1.UDP服务端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ss = socket()                      <span class="comment"># 创建一个服务器的套接字</span></span><br><span class="line">ss.bind()                          <span class="comment"># 绑定服务器套接字</span></span><br><span class="line">inf_loop:                          <span class="comment"># 服务器无限循环</span></span><br><span class="line">    cs = ss.recvfrom()/ss.sendto() <span class="comment"># 对话(接收与发送)</span></span><br><span class="line">ss.close()                         <span class="comment"># 关闭服务器套接字</span></span><br></pre></td></tr></table></figure>
<h2 id="2-UDP客户端"><a href="#2-UDP客户端" class="headerlink" title="2.UDP客户端"></a>2.UDP客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">cs = socket()                      <span class="comment"># 创建客户套接字</span></span><br><span class="line">comm_loop:                         <span class="comment"># 通讯循环</span></span><br><span class="line">    cs.sendto()/cs.recvfrom()      <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">cs.close()                         <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>
<h2 id="3-举例-1"><a href="#3-举例-1" class="headerlink" title="3.举例"></a>3.举例</h2><ul>
<li>服务端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(msg,addr)</span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line">    udp_server_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line">    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(back_msg.decode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure>
<h1 id="七、粘包现象以及粘包的解决方案"><a href="#七、粘包现象以及粘包的解决方案" class="headerlink" title="七、粘包现象以及粘包的解决方案"></a>七、粘包现象以及粘包的解决方案</h1><blockquote>
<p>  基于TCP的socket，在运行时会发生粘包；基于UDP的socket，在运行时永远不会发生粘包 。所以说粘包是TCP产生的一种特有的现象。</p>
</blockquote>
<p><strong>需要注意的是：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">					shell=<span class="keyword">True</span>,</span><br><span class="line">					stderr=subprocess.PIPE,</span><br><span class="line">					stdout=subprocess.PIPE)</span><br></pre></td></tr></table></figure>
<p>上述代码的结果编码是以当前所在的系统为准的，如果是windows，那么<strong><code>res.stdout.read()</code>读出的就是GBK编码的</strong>，在接收端需<strong>要用GBK解码</strong>，<strong>且只能从管道里读一次结果</strong>。</p>
<h2 id="1-Socket收发消息的原理"><a href="#1-Socket收发消息的原理" class="headerlink" title="1.Socket收发消息的原理"></a>1.Socket收发消息的原理</h2><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1544042942966&amp;di=d56193176396d1b0e47c55363a57ecb9&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180219180702013048.png" alt="Socket收发消息的原理"></p>
<p>发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此<strong>TCP协议是面向流的协议</strong>，这也是容易出现粘包问题的原因。而<strong>UDP是面向消息</strong>的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。 </p>
<blockquote>
<p>  <strong>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 </strong></p>
</blockquote>
<p>此外，发送方引起的粘包是由TCP协议本身造成的。</p>
<ol>
<li>TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。</li>
<li>若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</li>
</ol>
<blockquote>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 <strong>即面向消息的通信是有消息保护边界的。</strong></li>
<li><strong>TCP是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而UDP是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，UDP协议会帮你封装上消息头。</strong></li>
</ol>
</blockquote>
<p>UDP的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着UDP根本不会粘包，但是会丢数据，不可靠 </p>
<p>TCP的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。 </p>
<h2 id="2-发生粘包的两种情况"><a href="#2-发生粘包的两种情况" class="headerlink" title="2.发生粘包的两种情况"></a>2.发生粘包的两种情况</h2><ul>
<li>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包） </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">10</span>)</span><br><span class="line">data2=conn.recv(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.send(<span class="string">'feng'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">2</span>) <span class="comment">#一次没有收完整</span></span><br><span class="line">data2=conn.recv(<span class="number">10</span>)<span class="comment">#下次收的时候,会先取旧的数据,然后取新的</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello feng'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="3-拆包的发生情况"><a href="#3-拆包的发生情况" class="headerlink" title="3.拆包的发生情况"></a>3.拆包的发生情况</h2><p>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 </p>
<h2 id="4-为何TCP是可靠传输，UDP是不可靠传输"><a href="#4-为何TCP是可靠传输，UDP是不可靠传输" class="headerlink" title="4.为何TCP是可靠传输，UDP是不可靠传输"></a>4.为何TCP是可靠传输，UDP是不可靠传输</h2><blockquote>
<p>  TCP在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以TCP是可靠的。</p>
</blockquote>
<blockquote>
<p>  UDP发送数据，对端是不会返回确认信息的，因此不可靠。</p>
</blockquote>
<h2 id="5-send-字节流-和recv-1024-及sendall"><a href="#5-send-字节流-和recv-1024-及sendall" class="headerlink" title="5.send(字节流)和recv(1024)及sendall"></a>5.send(字节流)和recv(1024)及sendall</h2><blockquote>
<p>recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 </p>
</blockquote>
<blockquote>
<p>send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失 </p>
</blockquote>
<h2 id="6-解决粘包的处理方法"><a href="#6-解决粘包的处理方法" class="headerlink" title="6. 解决粘包的处理方法"></a><strong>6. 解决粘包的处理方法</strong></h2><blockquote>
<p>  为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据。</p>
</blockquote>
<ul>
<li>在解决粘包之前，我们先介绍下<strong>struct模块：</strong> 该模块可以把一个类型，如数字，转成固定长度的bytes 。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201704/1036857-20170422071900493-2119801952.png" alt="struct模块"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json,struct</span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line">header=&#123;<span class="string">'file_size'</span>:<span class="number">1073741824000</span>,<span class="string">'file_name'</span>:<span class="string">'/a/b/c/d/e/a.txt'</span>,<span class="string">'md5'</span>:<span class="string">'8f6fbf8347faa4924a76856701edb0f3'</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=bytes(json.dumps(header),encoding=<span class="string">'utf-8'</span>) <span class="comment">#序列化并转成bytes,用于传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">'i'</span>,len(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">'i'</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">'file_size'</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于struct的详细用法</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">values1 = (<span class="number">1</span>, <span class="string">'abc'</span>.encode(<span class="string">'utf-8'</span>), <span class="number">2.7</span>)</span><br><span class="line">values2 = (<span class="string">'defg'</span>.encode(<span class="string">'utf-8'</span>),<span class="number">101</span>)</span><br><span class="line">s1 = struct.Struct(<span class="string">'I3sf'</span>)</span><br><span class="line">s2 = struct.Struct(<span class="string">'4sI'</span>)</span><br><span class="line"></span><br><span class="line">print(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line">print(<span class="string">'Before : '</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="comment"># t=binascii.hexlify('asdfaf'.encode('utf-8'))</span></span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,<span class="number">0</span>,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s1.unpack_from(prebuffer,<span class="number">0</span>))</span><br><span class="line">print(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(<span class="string">'ii'</span>)</span><br><span class="line">s3.pack_into(prebuffer,<span class="number">0</span>,<span class="number">123</span>,<span class="number">123</span>)</span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s3.unpack_from(prebuffer,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>服务端（自定制报头）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="keyword">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(back_msg))) <span class="comment">#先发back_msg的长度</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端（自定制报头）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,time,struct</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    l=s.recv(<span class="number">4</span>)</span><br><span class="line">    x=struct.unpack(<span class="string">'i'</span>,l)[<span class="number">0</span>]</span><br><span class="line">    print(type(x),x)</span><br><span class="line">    <span class="comment"># print(struct.unpack('I',l))</span></span><br><span class="line">    r_s=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> r_s &lt; x:</span><br><span class="line">        r_d=s.recv(<span class="number">1024</span>)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=len(r_d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.decode('utf-8'))</span></span><br><span class="line">    print(data.decode(<span class="string">'gbk'</span>)) <span class="comment">#windows默认gbk编码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>具体思路步骤</li>
</ul>
<p>我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了） </p>
<blockquote>
<p>发送时：</p>
<p>先发报头长度</p>
<p>再编码报头内容然后发送</p>
<p>最后发真实内容</p>
</blockquote>
<blockquote>
<p>  接收时：</p>
<p>  先手报头长度，用struct取出来</p>
<p>  根据取出的长度收取报头内容，然后解码，反序列化</p>
<p>  从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</p>
</blockquote>
<ul>
<li>服务端复杂一点的报头</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment"># 就是它，在bind前加</span></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="keyword">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">'data_size'</span>:len(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(head_json_bytes))) <span class="comment"># 先发报头的长度</span></span><br><span class="line">        conn.send(head_json_bytes)                       <span class="comment"># 再发报头</span></span><br><span class="line">        conn.sendall(back_msg)                           <span class="comment"># 在发真实的内容</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,json</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    cmd=input(<span class="string">'&gt;&gt;: '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(bytes(cmd,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">'i'</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data_len=head_json[<span class="string">'data_size'</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># print(recv_data.decode('gbk')) #windows默认gbk编码</span></span><br></pre></td></tr></table></figure>
<h1 id="八、认证客户端的链接合法性"><a href="#八、认证客户端的链接合法性" class="headerlink" title="八、认证客户端的链接合法性"></a>八、认证客户端的链接合法性</h1><blockquote>
<p>  若想要在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现 </p>
</blockquote>
<ul>
<li>服务端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line"></span><br><span class="line">secret_key=<span class="string">b'linhaifeng bang bang bang'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    认证客户端链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">'开始验证新链接的合法性'</span>)</span><br><span class="line">    msg=os.urandom(<span class="number">32</span>)</span><br><span class="line">    conn.sendall(msg)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    respone=conn.recv(len(digest))</span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(respone,digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_handler</span><span class="params">(conn,bufsize=<span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> conn_auth(conn):</span><br><span class="line">        print(<span class="string">'该链接不合法,关闭'</span>)</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">'链接合法,开始通信'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data=conn.recv(bufsize)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">break</span></span><br><span class="line">        conn.sendall(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_handler</span><span class="params">(ip_port,bufsize,backlog=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    只处理链接</span></span><br><span class="line"><span class="string">    :param ip_port:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_server.bind(ip_port)</span><br><span class="line">    tcp_socket_server.listen(backlog)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        conn,addr=tcp_socket_server.accept()</span><br><span class="line">        print(<span class="string">'新连接[%s:%s]'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">        data_handler(conn,bufsize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    server_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<ul>
<li>合法客户端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line">secret_key=<span class="string">b'linhaifeng bang bang bang'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(ip_port,bufsize=<span class="number">1024</span>)</span>:</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<ul>
<li>不知道加密方式的非法客户端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(ip_port,bufsize=<span class="number">1024</span>)</span>:</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<ul>
<li>不知道secret_key 的非法客户端</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hmac,os</span><br><span class="line">secret_key=<span class="string">b'linhaifeng bang bang bang1111'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_auth</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    验证客户端到服务器的链接</span></span><br><span class="line"><span class="string">    :param conn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    msg=conn.recv(<span class="number">32</span>)</span><br><span class="line">    h=hmac.new(secret_key,msg)</span><br><span class="line">    digest=h.digest()</span><br><span class="line">    conn.sendall(digest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(ip_port,bufsize=<span class="number">1024</span>)</span>:</span></span><br><span class="line">    tcp_socket_client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    tcp_socket_client.connect(ip_port)</span><br><span class="line"></span><br><span class="line">    conn_auth(tcp_socket_client)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        tcp_socket_client.sendall(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        respone=tcp_socket_client.recv(bufsize)</span><br><span class="line">        print(respone.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    tcp_socket_client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line">    bufsize=<span class="number">1024</span></span><br><span class="line">    client_handler(ip_port,bufsize)</span><br></pre></td></tr></table></figure>
<h1 id="九、socketserver-实现并发"><a href="#九、socketserver-实现并发" class="headerlink" title="九、socketserver 实现并发"></a>九、socketserver 实现并发</h1><blockquote>
<p>  基于TCP的套接字，关键就是两个循环，一个链接循环，一个通信循环 。</p>
<p>  socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题） </p>
</blockquote>
<ul>
<li>server类</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170505014200961-1776184607.png" alt="server类"></p>
<ul>
<li>request类</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170505014309914-771361140.png" alt="request类"></p>
<ul>
<li>继承关系</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170505015158101-334152905.png" alt="继承关系1"></p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170505015247148-219054764.png" alt="继承关系2"></p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201705/1036857-20170505015356492-1711228984.png" alt="继承关系3"></p>
<p>以下述代码为例，分析socketserver源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftpserver=socketserver.ThreadingTCPServer((&apos;127.0.0.1&apos;,8080),FtpServer)</span><br><span class="line">ftpserver.serve_forever()</span><br></pre></td></tr></table></figure>
<p>查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer</p>
<ol>
<li>实例化得到ftpserver，先找类ThreadingTCPServer的<code>__init__</code>,在TCPServer中找到，进而执行server_bind,server_active</li>
<li>找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中</li>
<li>执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)</li>
<li>在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)</li>
<li>上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找<code>__init__</code>方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找….</li>
</ol>
<p>源码分析总结：</p>
<p>基于tcp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.server即套接字对象</li>
<li>　　self.request即一个链接</li>
<li>　　self.client_address即客户端地址</li>
</ol>
<p>基于udp的socketserver我们自己定义的类中的</p>
<ol>
<li>　　self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, &lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=(‘127.0.0.1’, 8080)&gt;)</li>
<li>　　self.client_address即客户端地址</li>
</ol>

        </div>

        <section class="meta">
            <time class="time" itemprop="dateUpdated" datetime="2018-12-06T02:35:17+08:00" content="2018-12-06">
                <i class="fas fa-pen fa-fw" aria-hidden="true"></i>
                本文最后更新于：2018-12-06
            </time>
            
                
                <div class="tags">
                    <i class="fas fa-tags fa-fw" aria-hidden="true"></i>
                    <a class="tag" href="/tags/Socket/">Socket</a>
                </div>
            
        </section>

        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一篇</h6>
                            <h4>
                                <a href="/2018/12/05/并发编程之多线程/" rel="prev" title="并发编程之多线程">
                                  
                                      并发编程之多线程
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <i class="fas fa-tags fa-fw" aria-hidden="true"></i>
                                    <a class="tag" href="/tags/多线程/">多线程</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一篇&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2018/12/03/Nginx部署/" rel="prev" title="WEB服务器之Nginx">
                                    
                                        WEB服务器之Nginx
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <i class="fas fa-tags fa-fw" aria-hidden="true"></i>
                                    <a class="tag" href="/tags/Nginx/">Nginx</a>, <a class="tag" href="/tags/uWSGI/">uWSGI</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->

    <article class="post white-box comments">
        <section class="article typo">

            
                

    <div class="recommended_posts">
        <h4><i class="fas fa-bookmark fa-fw" aria-hidden="true"></i>&nbsp;你可能感兴趣的文章</h4>
        <ul>
            
                <li><a href="http://yoursite.com/2018/12/05/并发编程之IO模型/">并发编程之 IO模型</a></li>
            
                <li><a href="http://yoursite.com/2018/12/05/并发编程之多线程/">并发编程之多线程</a></li>
            
                <li><a href="http://yoursite.com/2018/12/03/Nginx部署/">WEB服务器之Nginx</a></li>
            
                <li><a href="http://yoursite.com/2018/12/03/MySQL/">MySQL基础知识</a></li>
            
                <li><a href="http://yoursite.com/2018/12/03/并发编程之多进程/">并发编程之多进程</a></li>
            
        </ul>
    </div>


            

            

                

                
                    <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;LiveRe评论</h4>
                    <section id="comments">
                        <div id="lv-container" data-id="city" data-uid="MTAyMC80MTQxNi8xNzk2Mw==">
                            <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
                        </div>
                    </section>
                

                
            

        </section>
    </article>


<script>
    window.subData = {
        title: '网络编程Socket',
        tools: true
    }
</script>


        </div>
        <aside class='l_side'>
            
    
        
  <section class="m_widget author">
    
      <div class="header">
        <img class="avatar" src="https://xaoxuu.com/assets/img/avatar.jpg">
      </div>
    
    
      <div class="content">
        
        
          <p>最佳第六人</p>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhuohfeng@163.com" class="social flat-box" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/smart1san" class="social flat-box" target="_blank" rel="external"><i class="social fab fa-github-square" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=438614298" class="social flat-box" target="_blank" rel="external"><i class="social fas fa-headphones-alt" aria-hidden="true"></i></a>
          
        
      </div>
    
  </section>


    
    
        
  <section class="m_widget announcement">
    <header class="header pure">
        <div><i class="fas fa-bullhorn fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;公告</div>
    </header>
    <div class="content pure">
      在墨黑的夜空点燃自己，为远方的你送去一丝光明....那全部的幸福，都源自燃烧的我，暗夜中模糊的你....
    </div>
  </section>


    
    
        <section class="m_widget categories">
    <header class="header pure">
        <div><i class="fas fa-bookmark fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
    </header>
    <div class="content pure">
        
            <ul class="entry">
                
                    <li><a class="flat-box" href="/categories/Database/"><div class="name">Database</div><div class="badge">1</div></a></li>
                
                    <li><a class="flat-box" href="/categories/Django/"><div class="name">Django</div><div class="badge">1</div></a></li>
                
                    <li><a class="flat-box" href="/categories/Git/"><div class="name">Git</div><div class="badge">1</div></a></li>
                
                    <li><a class="flat-box" href="/categories/Nginx/"><div class="name">Nginx</div><div class="badge">1</div></a></li>
                
                    <li><a class="flat-box" href="/categories/Python/"><div class="name">Python</div><div class="badge">1</div></a></li>
                
                    <li><a class="flat-box" href="/categories/并发编程/"><div class="name">并发编程</div><div class="badge">5</div></a></li>
                
                    <li><a class="flat-box" href="/categories/网络编程/"><div class="name">网络编程</div><div class="badge">3</div></a></li>
                
                    <li><a class="flat-box" href="/categories/设计模式/"><div class="name">设计模式</div><div class="badge">1</div></a></li>
                
            </ul>
        
    </div>
</section>

    
    
        
    <section class="m_widget tagcloud">
        <header class="header pure">
            <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
        </header>
        <div class="content pure">
            <a href="/tags/Git/" style="font-size: 14px; color: #999">Git</a> <a href="/tags/HTTP/" style="font-size: 14px; color: #999">HTTP</a> <a href="/tags/IO模型/" style="font-size: 14px; color: #999">IO模型</a> <a href="/tags/MTV/" style="font-size: 14px; color: #999">MTV</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/Nginx/" style="font-size: 14px; color: #999">Nginx</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/Socket/" style="font-size: 14px; color: #999">Socket</a> <a href="/tags/TCP/" style="font-size: 14px; color: #999">TCP</a> <a href="/tags/UDP/" style="font-size: 14px; color: #999">UDP</a> <a href="/tags/restframework/" style="font-size: 14px; color: #999">restframework</a> <a href="/tags/sql/" style="font-size: 14px; color: #999">sql</a> <a href="/tags/uWSGI/" style="font-size: 14px; color: #999">uWSGI</a> <a href="/tags/协程/" style="font-size: 14px; color: #999">协程</a> <a href="/tags/多线程/" style="font-size: 14px; color: #999">多线程</a> <a href="/tags/多进程/" style="font-size: 14px; color: #999">多进程</a> <a href="/tags/消息队列/" style="font-size: 14px; color: #999">消息队列</a> <a href="/tags/生产者消费者模型/" style="font-size: 14px; color: #999">生产者消费者模型</a>
        </div>
    </section>


    
    
        
    <section class="m_widget toc-wrapper">
        <header class="header pure">
            <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class="wrapper"><a class="s-toc rightBtn" title="固定到顶部" target="_blank" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
        </header>
        <div class="content pure">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Socket层的位置"><span class="toc-text">一、Socket层的位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Socket的概念"><span class="toc-text">二、Socket的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、套接字家族发展史以及分类"><span class="toc-text">三、套接字家族发展史以及分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基于文件类型的套接字家族"><span class="toc-text">1.基于文件类型的套接字家族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-基于网络类型的套接字家族"><span class="toc-text">2.基于网络类型的套接字家族</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、套接字工作流程"><span class="toc-text">四、套接字工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-socket-模块函数用法"><span class="toc-text">1.socket()模块函数用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-服务端套接字函数"><span class="toc-text">2.服务端套接字函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-客户端套接字函数"><span class="toc-text">3.客户端套接字函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-公共用途的套接字函数"><span class="toc-text">4.公共用途的套接字函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-面向锁的套接字方法"><span class="toc-text">5.面向锁的套接字方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-面向文件的套接字的函数"><span class="toc-text">6.面向文件的套接字的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、基于TCP的套接字"><span class="toc-text">五、基于TCP的套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-TCP服务端"><span class="toc-text">1.TCP服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-TCP客户端"><span class="toc-text">2.TCP客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-举例"><span class="toc-text">3.举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、基于UDP的套接字"><span class="toc-text">六、基于UDP的套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UDP服务端"><span class="toc-text">1.UDP服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-UDP客户端"><span class="toc-text">2.UDP客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-举例-1"><span class="toc-text">3.举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、粘包现象以及粘包的解决方案"><span class="toc-text">七、粘包现象以及粘包的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Socket收发消息的原理"><span class="toc-text">1.Socket收发消息的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-发生粘包的两种情况"><span class="toc-text">2.发生粘包的两种情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-拆包的发生情况"><span class="toc-text">3.拆包的发生情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-为何TCP是可靠传输，UDP是不可靠传输"><span class="toc-text">4.为何TCP是可靠传输，UDP是不可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-send-字节流-和recv-1024-及sendall"><span class="toc-text">5.send(字节流)和recv(1024)及sendall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-解决粘包的处理方法"><span class="toc-text">6. 解决粘包的处理方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、认证客户端的链接合法性"><span class="toc-text">八、认证客户端的链接合法性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、socketserver-实现并发"><span class="toc-text">九、socketserver 实现并发</span></a></li></ol>
        </div>
    </section>


    
    
        <section class="m_widget music">
    <header class="header pure">
        <div><i class="fas fa-headphones fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;音乐</div>
        <a class="rightBtn" title="打开博主的网易云音乐主页" target="_blank" rel="external nofollow noopener noreferrer" href="https://music.163.com/#/playlist?id=2456408175"><i class="fas fa-external-link-square-alt fa-fw"></i></a>
    </header>
    <div class="content pure">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="450" src="//music.163.com/outchain/player?type=0&id=2456408175&auto=0&height=450"></iframe>
    </div>
</section>

    
    
        <section class="m_widget links">
    <header class="header pure">
        <div><i class="fas fa-handshake fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;友链</div>
        
            <a class="rightBtn" title="联系博主添加友链" target="_blank" rel="external nofollow noopener noreferrer" href="mailto:me@xaoxuu.com?subject=交换友链&body=你好，我想和你交换友链，我已经将【VIP】添加到我的博客的友链中。我的博客链接是："><i class="fas fa-plus fa-fw"></i></a>
        
    </header>
    <div class="content pure">
        <ul class="entry" id="links">
            
                <li><a class="flat-box" title="https://github.com/smart1san" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/smart1san">
                    <div class="name">
                        
                            <img src="https://xaoxuu.com/assets/img/avatar.jpg">
                        
                        &nbsp;&nbsp;smart1san&#39;s github
                    </div>
                </a></li>
            
        </ul>
    </div>
</section>

    


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    </div>
    <footer id="footer" class="clearfix">
    
        <div class="social-wrapper">
          
              
                  <a href="mailto:zhuohfeng@163.com" class="social fas fa-envelope flat-box" target="_blank" rel="external"></a>
              
          
              
                  <a href="https://github.com/smart1san" class="social fab fa-github-square flat-box" target="_blank" rel="external"></a>
              
          
              
                  <a href="https://music.163.com/#/user/home?id=438614298" class="social fas fa-headphones-alt flat-box" target="_blank" rel="external"></a>
              
          
        </div>
    
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>
        本站总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>
</footer>
<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->


    <script>setLoadingBarProgress(80);</script>
    <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/node-waves/0.7.5/waves.min.js"></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/jquery.fitvids.js"></script>

    <script>
        var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
        var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
        var ALGOLIA_API_KEY = "";
        var ALGOLIA_APP_ID = "";
        var ALGOLIA_INDEX_NAME = "";
        var AZURE_SERVICE_NAME = "";
        var AZURE_INDEX_NAME = "";
        var AZURE_QUERY_KEY = "";
        var BAIDU_API_ID = "";
        var SEARCH_SERVICE = "hexo" || "hexo";
        var ROOT = "/"||"/";
        if(!ROOT.endsWith('/'))ROOT += '/';
    </script>

<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
        <script type="text/javascript">
           (function(d, s) {
               var j, e = d.getElementsByTagName(s)[0];
               if (typeof LivereTower === 'function') { return; }
               j = d.createElement(s);
               j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
               j.async = true;
               e.parentNode.insertBefore(j, e);
           })(document, 'script');
        </script>
    
    




  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
  function showTime(Counter) {
    var query = new AV.Query(Counter);
    var entries = [];
    var $visitors = $(".leancloud_visitors");

    $visitors.each(function () {
      entries.push( $(this).attr("id").trim() );
    });

    query.containedIn('url', entries);
    query.find()
      .done(function (results) {
        var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

        if (results.length === 0) {
          $visitors.find(COUNT_CONTAINER_REF).text(0);
          return;
        }

        for (var i = 0; i < results.length; i++) {
          var item = results[i];
          var url = item.get('url');
          var time = item.get('time');
          var element = document.getElementById(url);

          $(element).find(COUNT_CONTAINER_REF).text(time);
        }
        for(var i = 0; i < entries.length; i++) {
          var url = entries[i];
          var element = document.getElementById(url);
          var countSpan = $(element).find(COUNT_CONTAINER_REF);
          if( countSpan.text() == '') {
            countSpan.text(0);
          }
        }
      })
      .fail(function (object, error) {
        console.log("Error: " + error.code + " " + error.message);
      });
  }

  function addCount(Counter) {
    var $visitors = $(".leancloud_visitors");
    var url = $visitors.attr('id').trim();
    var title = $visitors.attr('data-flag-title').trim();
    var query = new AV.Query(Counter);

    query.equalTo("url", url);
    query.find({
      success: function(results) {
        if (results.length > 0) {
          var counter = results[0];
          counter.fetchWhenSave(true);
          counter.increment("time");
          counter.save(null, {
            success: function(counter) {
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text(counter.get('time'));
            },
            error: function(counter, error) {
              console.log('Failed to save Visitor num, with error message: ' + error.message);
            }
          });
        } else {
          var newcounter = new Counter();
          /* Set ACL */
          var acl = new AV.ACL();
          acl.setPublicReadAccess(true);
          acl.setPublicWriteAccess(true);
          newcounter.setACL(acl);
          /* End Set ACL */
          newcounter.set("title", title);
          newcounter.set("url", url);
          newcounter.set("time", 1);
          newcounter.save(null, {
            success: function(newcounter) {
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
            },
            error: function(newcounter, error) {
              console.log('Failed to create');
            }
          });
        }
      },
      error: function(error) {
        console.log('Error:' + error.code + " " + error.message);
      }
    });
  }

  $(function() {
    var Counter = AV.Object.extend("Counter");
    if ($('.leancloud_visitors').length == 1) {
      addCount(Counter);
    } else if ($('.post-title-link').length > 1) {
      showTime(Counter);
    }
  });
</script>


    <script>setLoadingBarProgress(100);</script>
</body>
